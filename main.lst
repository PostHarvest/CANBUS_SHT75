CCS PCH C Compiler, Version 5.025, 40073               22-Thg11-17 10:31

               Filename:   D:\du lieu\BSD\BSD datasheet\SHT75\sht_pic_18f2480_can transfer\REPORT SHT BME280 TRANSFER\main.lst

               ROM used:   6660 bytes (41%)
                           Largest free fragment is 9720
               RAM used:   67 (9%) at main() level
                           135 (18%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   10E6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00AE
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                            EX_CAN.C                             //// 
.................... ////                                                                 //// 
.................... //// Example of CCS's CAN library, using the PIC18Fxx8.  This        //// 
.................... //// example was tested using MCP250xxx CAN Developer's Kit.         //// 
.................... ////                                                                 //// 
.................... //// Connect pin B2 (CANTX) to the CANTX pin on the open NODE A of   //// 
.................... //// the developer's kit, and connect pin B3 (CANRX) to the CANRX    //// 
.................... //// pin on the open NODE A.                                         //// 
.................... ////                                                                 //// 
.................... //// NODE B has an MCP250xxx which sends and responds certan canned  //// 
.................... //// messages.  For example, hitting one of the GPX buttons on       //// 
.................... //// the development kit causes the MCP250xxx to send a 2 byte       //// 
.................... //// message with an ID of 0x290.  After pressing one of those       //// 
.................... //// buttons with this firmware you should see this message          //// 
.................... //// displayed over RS232.                                           //// 
.................... ////                                                                 //// 
.................... //// NODE B also responds to certain CAN messages.  If you send      //// 
.................... //// a request (RTR bit set) with an ID of 0x18 then NODE B will     //// 
.................... //// respond with an 8-byte message containing certain readings.     //// 
.................... //// This firmware sends this request every 2 seconds, which NODE B  //// 
.................... //// responds.                                                       //// 
.................... ////                                                                 //// 
.................... //// If you install Microchip's CANKing software and use the         //// 
.................... //// MCP250xxx , you can see all the CAN traffic and validate all    //// 
.................... //// experiments.                                                    //// 
.................... ////                                                                 //// 
.................... //// For more documentation on the CCS CAN library, see can-18xxx8.c //// 
.................... ////                                                                 //// 
.................... ////  Jumpers:                                                       //// 
.................... ////     PCM,PCH    pin C7 to RS232 RX, pin C6 to RS232 TX           //// 
.................... ////                                                                 //// 
.................... ////  This example will work with the PCM and PCH compilers.         //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <18F2480.h> 
.................... //////////// Standard Header file for the PIC18F2480 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2480 
*
00BA:  DATA 0D,0A
00BC:  DATA 0D,0A
00BE:  DATA 43,43
00C0:  DATA 53,20
00C2:  DATA 43,41
00C4:  DATA 4E,20
00C6:  DATA 54,52
00C8:  DATA 41,4E
00CA:  DATA 53,46
00CC:  DATA 45,52
00CE:  DATA 20,42
00D0:  DATA 4D,45
00D2:  DATA 32,38
00D4:  DATA 30,20
00D6:  DATA 44,41
00D8:  DATA 54,41
00DA:  DATA 0D,0A
00DC:  DATA 00,00
00DE:  DATA 0D,0A
00E0:  DATA 52,75
00E2:  DATA 6E,6E
00E4:  DATA 69,6E
00E6:  DATA 67,2E
00E8:  DATA 2E,2E
00EA:  DATA 00,00
00EC:  DATA 0D,0A
00EE:  DATA 54,65
00F0:  DATA 6D,70
00F2:  DATA 65,72
00F4:  DATA 61,74
00F6:  DATA 75,72
00F8:  DATA 65,20
00FA:  DATA 53,48
00FC:  DATA 54,37
00FE:  DATA 31,20
0100:  DATA 3D,20
0102:  DATA 25,66
0104:  DATA 33,00
0106:  DATA 0D,0A
0108:  DATA 48,75
010A:  DATA 6D,69
010C:  DATA 64,69
010E:  DATA 74,79
0110:  DATA 20,53
0112:  DATA 48,54
0114:  DATA 37,31
0116:  DATA 20,3D
0118:  DATA 20,25
011A:  DATA 66,33
011C:  DATA 00,00
011E:  DATA 0D,0A
0120:  DATA 47,4F
0122:  DATA 54,3A
0124:  DATA 20,42
0126:  DATA 55,46
0128:  DATA 46,3D
012A:  DATA 25,55
012C:  DATA 20,49
012E:  DATA 44,3D
0130:  DATA 25,4C
0132:  DATA 55,20
0134:  DATA 4C,45
0136:  DATA 4E,3D
0138:  DATA 25,55
013A:  DATA 20,4F
013C:  DATA 56,46
013E:  DATA 3D,25
0140:  DATA 55,20
0142:  DATA 00,00
0144:  DATA 46,49
0146:  DATA 4C,54
0148:  DATA 3D,25
014A:  DATA 55,20
014C:  DATA 52,54
014E:  DATA 52,3D
0150:  DATA 25,55
0152:  DATA 20,45
0154:  DATA 58,54
0156:  DATA 3D,25
0158:  DATA 55,20
015A:  DATA 49,4E
015C:  DATA 56,3D
015E:  DATA 25,55
0160:  DATA 00,00
0162:  DATA 0D,0A
0164:  DATA 20,20
0166:  DATA 20,20
0168:  DATA 44,41
016A:  DATA 54,41
016C:  DATA 20,3D
016E:  DATA 20,00
0170:  DATA 0D,0A
0172:  DATA 46,41
0174:  DATA 49,4C
0176:  DATA 20,6F
0178:  DATA 6E,20
017A:  DATA 47,45
017C:  DATA 54,44
017E:  DATA 0D,0A
0180:  DATA 00,00
0182:  DATA 0D,0A
0184:  DATA 50,55
0186:  DATA 54,20
0188:  DATA 25,55
018A:  DATA 3A,20
018C:  DATA 49,44
018E:  DATA 3D,25
0190:  DATA 4C,55
0192:  DATA 20,4C
0194:  DATA 45,4E
0196:  DATA 3D,25
0198:  DATA 55,20
019A:  DATA 00,00
019C:  DATA 50,52
019E:  DATA 49,3D
01A0:  DATA 25,55
01A2:  DATA 20,45
01A4:  DATA 58,54
01A6:  DATA 3D,25
01A8:  DATA 55,20
01AA:  DATA 52,54
01AC:  DATA 52,3D
01AE:  DATA 25,55
01B0:  DATA 0D,0A
01B2:  DATA 20,20
01B4:  DATA 20,44
01B6:  DATA 41,54
01B8:  DATA 41,20
01BA:  DATA 3D,20
01BC:  DATA 00,00
01BE:  DATA 0D,0A
01C0:  DATA 50,55
01C2:  DATA 54,20
01C4:  DATA 25,55
01C6:  DATA 3A,20
01C8:  DATA 49,44
01CA:  DATA 3D,25
01CC:  DATA 4C,55
01CE:  DATA 20,4C
01D0:  DATA 45,4E
01D2:  DATA 3D,25
01D4:  DATA 55,20
01D6:  DATA 00,00
01D8:  DATA 0D,0A
01DA:  DATA 46,41
01DC:  DATA 49,4C
01DE:  DATA 20,6F
01E0:  DATA 6E,20
01E2:  DATA 50,55
01E4:  DATA 54,44
01E6:  DATA 0D,0A
01E8:  DATA 00,00
01EA:  TBLRD*+
01EC:  MOVF   FF5,F
01EE:  BZ    020A
01F0:  MOVFF  FF6,4F
01F4:  MOVFF  FF7,50
01F8:  MOVF   FF5,W
01FA:  BTFSS  F9E.4
01FC:  BRA    01FA
01FE:  MOVWF  FAD
0200:  MOVFF  4F,FF6
0204:  MOVFF  50,FF7
0208:  BRA    01EA
020A:  RETURN 0
*
069E:  MOVLW  8E
06A0:  MOVWF  00
06A2:  MOVFF  74,01
06A6:  MOVFF  73,02
06AA:  CLRF   03
06AC:  MOVF   01,F
06AE:  BNZ   06C2
06B0:  MOVFF  02,01
06B4:  CLRF   02
06B6:  MOVLW  08
06B8:  SUBWF  00,F
06BA:  MOVF   01,F
06BC:  BNZ   06C2
06BE:  CLRF   00
06C0:  BRA    06D2
06C2:  BCF    FD8.0
06C4:  BTFSC  01.7
06C6:  BRA    06D0
06C8:  RLCF   02,F
06CA:  RLCF   01,F
06CC:  DECF   00,F
06CE:  BRA    06C2
06D0:  BCF    01.7
06D2:  RETURN 0
*
06FC:  MOVF   x7B,W
06FE:  BTFSC  FD8.2
0700:  BRA    07E4
0702:  MOVWF  00
0704:  MOVF   x7F,W
0706:  BTFSC  FD8.2
0708:  BRA    07E4
070A:  ADDWF  00,F
070C:  BNC   0716
070E:  MOVLW  81
0710:  ADDWF  00,F
0712:  BC    07E4
0714:  BRA    071E
0716:  MOVLW  7F
0718:  SUBWF  00,F
071A:  BNC   07E4
071C:  BZ    07E4
071E:  MOVFF  7C,83
0722:  MOVF   x80,W
0724:  XORWF  x83,F
0726:  BSF    x7C.7
0728:  BSF    x80.7
072A:  MOVF   x7E,W
072C:  MULWF  x82
072E:  MOVFF  FF4,85
0732:  MOVF   x7D,W
0734:  MULWF  x81
0736:  MOVFF  FF4,03
073A:  MOVFF  FF3,84
073E:  MULWF  x82
0740:  MOVF   FF3,W
0742:  ADDWF  x85,F
0744:  MOVF   FF4,W
0746:  ADDWFC x84,F
0748:  MOVLW  00
074A:  ADDWFC 03,F
074C:  MOVF   x7E,W
074E:  MULWF  x81
0750:  MOVF   FF3,W
0752:  ADDWF  x85,F
0754:  MOVF   FF4,W
0756:  ADDWFC x84,F
0758:  MOVLW  00
075A:  CLRF   02
075C:  ADDWFC 03,F
075E:  ADDWFC 02,F
0760:  MOVF   x7C,W
0762:  MULWF  x82
0764:  MOVF   FF3,W
0766:  ADDWF  x84,F
0768:  MOVF   FF4,W
076A:  ADDWFC 03,F
076C:  MOVLW  00
076E:  ADDWFC 02,F
0770:  MOVF   x7C,W
0772:  MULWF  x81
0774:  MOVF   FF3,W
0776:  ADDWF  03,F
0778:  MOVF   FF4,W
077A:  ADDWFC 02,F
077C:  MOVLW  00
077E:  CLRF   01
0780:  ADDWFC 01,F
0782:  MOVF   x7E,W
0784:  MULWF  x80
0786:  MOVF   FF3,W
0788:  ADDWF  x84,F
078A:  MOVF   FF4,W
078C:  ADDWFC 03,F
078E:  MOVLW  00
0790:  ADDWFC 02,F
0792:  ADDWFC 01,F
0794:  MOVF   x7D,W
0796:  MULWF  x80
0798:  MOVF   FF3,W
079A:  ADDWF  03,F
079C:  MOVF   FF4,W
079E:  ADDWFC 02,F
07A0:  MOVLW  00
07A2:  ADDWFC 01,F
07A4:  MOVF   x7C,W
07A6:  MULWF  x80
07A8:  MOVF   FF3,W
07AA:  ADDWF  02,F
07AC:  MOVF   FF4,W
07AE:  ADDWFC 01,F
07B0:  INCF   00,F
07B2:  BTFSC  01.7
07B4:  BRA    07C0
07B6:  RLCF   x84,F
07B8:  RLCF   03,F
07BA:  RLCF   02,F
07BC:  RLCF   01,F
07BE:  DECF   00,F
07C0:  MOVLW  00
07C2:  BTFSS  x84.7
07C4:  BRA    07DA
07C6:  INCF   03,F
07C8:  ADDWFC 02,F
07CA:  ADDWFC 01,F
07CC:  MOVF   01,W
07CE:  BNZ   07DA
07D0:  MOVF   02,W
07D2:  BNZ   07DA
07D4:  MOVF   03,W
07D6:  BNZ   07DA
07D8:  INCF   00,F
07DA:  BTFSC  x83.7
07DC:  BSF    01.7
07DE:  BTFSS  x83.7
07E0:  BCF    01.7
07E2:  BRA    07EC
07E4:  CLRF   00
07E6:  CLRF   01
07E8:  CLRF   02
07EA:  CLRF   03
07EC:  RETURN 0
07EE:  MOVLW  80
07F0:  BTFSC  FD8.1
07F2:  XORWF  x7C,F
07F4:  CLRF   x81
07F6:  CLRF   x82
07F8:  MOVFF  78,80
07FC:  MOVF   x7C,W
07FE:  XORWF  x80,F
0800:  MOVF   x77,W
0802:  BTFSC  FD8.2
0804:  BRA    09BE
0806:  MOVWF  x7F
0808:  MOVWF  00
080A:  MOVF   x7B,W
080C:  BTFSC  FD8.2
080E:  BRA    09D0
0810:  SUBWF  x7F,F
0812:  BTFSC  FD8.2
0814:  BRA    0918
0816:  BNC   0892
0818:  MOVFF  7C,85
081C:  BSF    x85.7
081E:  MOVFF  7D,84
0822:  MOVFF  7E,83
0826:  CLRF   x82
0828:  BCF    FD8.0
082A:  RRCF   x85,F
082C:  RRCF   x84,F
082E:  RRCF   x83,F
0830:  RRCF   x82,F
0832:  DECFSZ x7F,F
0834:  BRA    0826
0836:  BTFSS  x80.7
0838:  BRA    0840
083A:  BSF    x81.0
083C:  BRA    09F8
083E:  BCF    x81.0
0840:  BCF    x7F.0
0842:  BSF    x81.4
0844:  CLRF   FEA
0846:  MOVLW  7A
0848:  MOVWF  FE9
084A:  BRA    0A1E
084C:  BCF    x81.4
084E:  BTFSC  x80.7
0850:  BRA    0866
0852:  BTFSS  x7F.0
0854:  BRA    087C
0856:  RRCF   x85,F
0858:  RRCF   x84,F
085A:  RRCF   x83,F
085C:  RRCF   x82,F
085E:  INCF   00,F
0860:  BTFSC  FD8.2
0862:  BRA    09EE
0864:  BRA    087C
0866:  BTFSC  x85.7
0868:  BRA    0882
086A:  BCF    FD8.0
086C:  RLCF   x82,F
086E:  RLCF   x83,F
0870:  RLCF   x84,F
0872:  RLCF   x85,F
0874:  DECF   00,F
0876:  BTFSC  FD8.2
0878:  BRA    09EE
087A:  BRA    0866
087C:  BSF    x81.6
087E:  BRA    0956
0880:  BCF    x81.6
0882:  MOVFF  78,80
0886:  BTFSS  x78.7
0888:  BRA    088E
088A:  BSF    x85.7
088C:  BRA    09E0
088E:  BCF    x85.7
0890:  BRA    09E0
0892:  MOVFF  7B,7F
0896:  MOVFF  7B,00
089A:  MOVF   x77,W
089C:  SUBWF  x7F,F
089E:  MOVFF  78,85
08A2:  BSF    x85.7
08A4:  MOVFF  79,84
08A8:  MOVFF  7A,83
08AC:  CLRF   x82
08AE:  BCF    FD8.0
08B0:  RRCF   x85,F
08B2:  RRCF   x84,F
08B4:  RRCF   x83,F
08B6:  RRCF   x82,F
08B8:  DECFSZ x7F,F
08BA:  BRA    08AC
08BC:  BTFSS  x80.7
08BE:  BRA    08C6
08C0:  BSF    x81.1
08C2:  BRA    09F8
08C4:  BCF    x81.1
08C6:  BCF    x7F.0
08C8:  BSF    x81.5
08CA:  CLRF   FEA
08CC:  MOVLW  7E
08CE:  MOVWF  FE9
08D0:  BRA    0A1E
08D2:  BCF    x81.5
08D4:  BTFSC  x80.7
08D6:  BRA    08EC
08D8:  BTFSS  x7F.0
08DA:  BRA    0902
08DC:  RRCF   x85,F
08DE:  RRCF   x84,F
08E0:  RRCF   x83,F
08E2:  RRCF   x82,F
08E4:  INCF   00,F
08E6:  BTFSC  FD8.2
08E8:  BRA    09EE
08EA:  BRA    0902
08EC:  BTFSC  x85.7
08EE:  BRA    0908
08F0:  BCF    FD8.0
08F2:  RLCF   x82,F
08F4:  RLCF   x83,F
08F6:  RLCF   x84,F
08F8:  RLCF   x85,F
08FA:  DECF   00,F
08FC:  BTFSC  FD8.2
08FE:  BRA    09EE
0900:  BRA    08EC
0902:  BSF    x81.7
0904:  BRA    0956
0906:  BCF    x81.7
0908:  MOVFF  7C,80
090C:  BTFSS  x7C.7
090E:  BRA    0914
0910:  BSF    x85.7
0912:  BRA    09E0
0914:  BCF    x85.7
0916:  BRA    09E0
0918:  MOVFF  7C,85
091C:  BSF    x85.7
091E:  MOVFF  7D,84
0922:  MOVFF  7E,83
0926:  BTFSS  x80.7
0928:  BRA    0932
092A:  BCF    x85.7
092C:  BSF    x81.2
092E:  BRA    09F8
0930:  BCF    x81.2
0932:  CLRF   x82
0934:  BCF    x7F.0
0936:  CLRF   FEA
0938:  MOVLW  7A
093A:  MOVWF  FE9
093C:  BRA    0A1E
093E:  BTFSC  x80.7
0940:  BRA    097A
0942:  MOVFF  78,80
0946:  BTFSS  x7F.0
0948:  BRA    0956
094A:  RRCF   x85,F
094C:  RRCF   x84,F
094E:  RRCF   x83,F
0950:  RRCF   x82,F
0952:  INCF   00,F
0954:  BZ    09EE
0956:  BTFSS  x82.7
0958:  BRA    0970
095A:  INCF   x83,F
095C:  BNZ   0970
095E:  INCF   x84,F
0960:  BNZ   0970
0962:  INCF   x85,F
0964:  BNZ   0970
0966:  RRCF   x85,F
0968:  RRCF   x84,F
096A:  RRCF   x83,F
096C:  INCF   00,F
096E:  BZ    09EE
0970:  BTFSC  x81.6
0972:  BRA    0880
0974:  BTFSC  x81.7
0976:  BRA    0906
0978:  BRA    09B2
097A:  MOVLW  80
097C:  XORWF  x85,F
097E:  BTFSS  x85.7
0980:  BRA    098A
0982:  BRA    09F8
0984:  MOVFF  7C,80
0988:  BRA    099E
098A:  MOVFF  78,80
098E:  MOVF   x85,F
0990:  BNZ   099E
0992:  MOVF   x84,F
0994:  BNZ   099E
0996:  MOVF   x83,F
0998:  BNZ   099E
099A:  CLRF   00
099C:  BRA    09E0
099E:  BTFSC  x85.7
09A0:  BRA    09B2
09A2:  BCF    FD8.0
09A4:  RLCF   x82,F
09A6:  RLCF   x83,F
09A8:  RLCF   x84,F
09AA:  RLCF   x85,F
09AC:  DECFSZ 00,F
09AE:  BRA    099E
09B0:  BRA    09EE
09B2:  BTFSS  x80.7
09B4:  BRA    09BA
09B6:  BSF    x85.7
09B8:  BRA    09E0
09BA:  BCF    x85.7
09BC:  BRA    09E0
09BE:  MOVFF  7B,00
09C2:  MOVFF  7C,85
09C6:  MOVFF  7D,84
09CA:  MOVFF  7E,83
09CE:  BRA    09E0
09D0:  MOVFF  77,00
09D4:  MOVFF  78,85
09D8:  MOVFF  79,84
09DC:  MOVFF  7A,83
09E0:  MOVFF  85,01
09E4:  MOVFF  84,02
09E8:  MOVFF  83,03
09EC:  BRA    0A56
09EE:  CLRF   00
09F0:  CLRF   01
09F2:  CLRF   02
09F4:  CLRF   03
09F6:  BRA    0A56
09F8:  CLRF   x82
09FA:  COMF   x83,F
09FC:  COMF   x84,F
09FE:  COMF   x85,F
0A00:  COMF   x82,F
0A02:  INCF   x82,F
0A04:  BNZ   0A10
0A06:  INCF   x83,F
0A08:  BNZ   0A10
0A0A:  INCF   x84,F
0A0C:  BNZ   0A10
0A0E:  INCF   x85,F
0A10:  BTFSC  x81.0
0A12:  BRA    083E
0A14:  BTFSC  x81.1
0A16:  BRA    08C4
0A18:  BTFSC  x81.2
0A1A:  BRA    0930
0A1C:  BRA    0984
0A1E:  MOVF   FEF,W
0A20:  ADDWF  x83,F
0A22:  BNC   0A2E
0A24:  INCF   x84,F
0A26:  BNZ   0A2E
0A28:  INCF   x85,F
0A2A:  BTFSC  FD8.2
0A2C:  BSF    x7F.0
0A2E:  MOVF   FED,F
0A30:  MOVF   FEF,W
0A32:  ADDWF  x84,F
0A34:  BNC   0A3C
0A36:  INCF   x85,F
0A38:  BTFSC  FD8.2
0A3A:  BSF    x7F.0
0A3C:  MOVF   FED,F
0A3E:  MOVF   FEF,W
0A40:  BTFSC  FEF.7
0A42:  BRA    0A46
0A44:  XORLW  80
0A46:  ADDWF  x85,F
0A48:  BTFSC  FD8.0
0A4A:  BSF    x7F.0
0A4C:  BTFSC  x81.4
0A4E:  BRA    084C
0A50:  BTFSC  x81.5
0A52:  BRA    08D2
0A54:  BRA    093E
0A56:  RETURN 0
0A58:  TBLRD*+
0A5A:  MOVFF  FF6,54
0A5E:  MOVFF  FF7,55
0A62:  MOVF   FF5,W
0A64:  BTFSS  F9E.4
0A66:  BRA    0A64
0A68:  MOVWF  FAD
0A6A:  MOVFF  54,FF6
0A6E:  MOVFF  55,FF7
0A72:  DECFSZ 53,F
0A74:  BRA    0A58
0A76:  RETURN 0
0A78:  MOVF   5C,W
0A7A:  SUBLW  B6
0A7C:  MOVWF  5C
0A7E:  CLRF   03
0A80:  MOVFF  5D,60
0A84:  BSF    5D.7
0A86:  BCF    FD8.0
0A88:  RRCF   5D,F
0A8A:  RRCF   5E,F
0A8C:  RRCF   5F,F
0A8E:  RRCF   03,F
0A90:  RRCF   02,F
0A92:  RRCF   01,F
0A94:  RRCF   00,F
0A96:  DECFSZ 5C,F
0A98:  BRA    0A86
0A9A:  BTFSS  x60.7
0A9C:  BRA    0AB4
0A9E:  COMF   00,F
0AA0:  COMF   01,F
0AA2:  COMF   02,F
0AA4:  COMF   03,F
0AA6:  INCF   00,F
0AA8:  BTFSC  FD8.2
0AAA:  INCF   01,F
0AAC:  BTFSC  FD8.2
0AAE:  INCF   02,F
0AB0:  BTFSC  FD8.2
0AB2:  INCF   03,F
0AB4:  GOTO   0B94 (RETURN)
0AB8:  BTFSC  FD8.1
0ABA:  BRA    0AC2
0ABC:  CLRF   FEA
0ABE:  MOVLW  65
0AC0:  MOVWF  FE9
0AC2:  CLRF   00
0AC4:  CLRF   01
0AC6:  CLRF   02
0AC8:  CLRF   03
0ACA:  CLRF   x65
0ACC:  CLRF   x66
0ACE:  CLRF   x67
0AD0:  CLRF   x68
0AD2:  MOVF   x64,W
0AD4:  IORWF  x63,W
0AD6:  IORWF  x62,W
0AD8:  IORWF  x61,W
0ADA:  BZ    0B34
0ADC:  MOVLW  20
0ADE:  MOVWF  x69
0AE0:  BCF    FD8.0
0AE2:  RLCF   5D,F
0AE4:  RLCF   5E,F
0AE6:  RLCF   5F,F
0AE8:  RLCF   x60,F
0AEA:  RLCF   x65,F
0AEC:  RLCF   x66,F
0AEE:  RLCF   x67,F
0AF0:  RLCF   x68,F
0AF2:  MOVF   x64,W
0AF4:  SUBWF  x68,W
0AF6:  BNZ   0B08
0AF8:  MOVF   x63,W
0AFA:  SUBWF  x67,W
0AFC:  BNZ   0B08
0AFE:  MOVF   x62,W
0B00:  SUBWF  x66,W
0B02:  BNZ   0B08
0B04:  MOVF   x61,W
0B06:  SUBWF  x65,W
0B08:  BNC   0B28
0B0A:  MOVF   x61,W
0B0C:  SUBWF  x65,F
0B0E:  MOVF   x62,W
0B10:  BTFSS  FD8.0
0B12:  INCFSZ x62,W
0B14:  SUBWF  x66,F
0B16:  MOVF   x63,W
0B18:  BTFSS  FD8.0
0B1A:  INCFSZ x63,W
0B1C:  SUBWF  x67,F
0B1E:  MOVF   x64,W
0B20:  BTFSS  FD8.0
0B22:  INCFSZ x64,W
0B24:  SUBWF  x68,F
0B26:  BSF    FD8.0
0B28:  RLCF   00,F
0B2A:  RLCF   01,F
0B2C:  RLCF   02,F
0B2E:  RLCF   03,F
0B30:  DECFSZ x69,F
0B32:  BRA    0AE0
0B34:  MOVFF  65,FEF
0B38:  MOVFF  66,FEC
0B3C:  MOVFF  67,FEC
0B40:  MOVFF  68,FEC
0B44:  RETURN 0
0B46:  MOVF   FE9,W
0B48:  MOVWF  54
0B4A:  MOVF   53,W
0B4C:  MOVWF  56
0B4E:  BZ    0B82
0B50:  MOVFF  52,7E
0B54:  MOVFF  51,7D
0B58:  MOVFF  50,7C
0B5C:  MOVFF  4F,7B
0B60:  CLRF   x82
0B62:  CLRF   x81
0B64:  MOVLW  20
0B66:  MOVWF  x80
0B68:  MOVLW  82
0B6A:  MOVWF  x7F
0B6C:  RCALL  06FC
0B6E:  MOVFF  03,52
0B72:  MOVFF  02,51
0B76:  MOVFF  01,50
0B7A:  MOVFF  00,4F
0B7E:  DECFSZ 56,F
0B80:  BRA    0B50
0B82:  MOVFF  52,5F
0B86:  MOVFF  51,5E
0B8A:  MOVFF  50,5D
0B8E:  MOVFF  4F,5C
0B92:  BRA    0A78
0B94:  MOVFF  03,52
0B98:  MOVFF  02,51
0B9C:  MOVFF  01,50
0BA0:  MOVFF  00,4F
0BA4:  BTFSS  52.7
0BA6:  BRA    0BC2
0BA8:  DECF   54,F
0BAA:  BSF    54.5
0BAC:  COMF   4F,F
0BAE:  COMF   50,F
0BB0:  COMF   51,F
0BB2:  COMF   52,F
0BB4:  INCF   4F,F
0BB6:  BTFSC  FD8.2
0BB8:  INCF   50,F
0BBA:  BTFSC  FD8.2
0BBC:  INCF   51,F
0BBE:  BTFSC  FD8.2
0BC0:  INCF   52,F
0BC2:  MOVLW  3B
0BC4:  MOVWF  5B
0BC6:  MOVLW  9A
0BC8:  MOVWF  5A
0BCA:  MOVLW  CA
0BCC:  MOVWF  59
0BCE:  CLRF   58
0BD0:  MOVLW  0A
0BD2:  MOVWF  56
0BD4:  MOVF   53,W
0BD6:  BTFSC  FD8.2
0BD8:  INCF   54,F
0BDA:  BSF    FD8.1
0BDC:  CLRF   FEA
0BDE:  MOVLW  4F
0BE0:  MOVWF  FE9
0BE2:  MOVFF  52,60
0BE6:  MOVFF  51,5F
0BEA:  MOVFF  50,5E
0BEE:  MOVFF  4F,5D
0BF2:  MOVFF  5B,64
0BF6:  MOVFF  5A,63
0BFA:  MOVFF  59,62
0BFE:  MOVFF  58,61
0C02:  RCALL  0AB8
0C04:  MOVF   01,W
0C06:  MOVF   00,F
0C08:  BNZ   0C28
0C0A:  INCF   53,W
0C0C:  SUBWF  56,W
0C0E:  BZ    0C28
0C10:  MOVF   54,W
0C12:  BZ    0C2C
0C14:  ANDLW  0F
0C16:  SUBWF  56,W
0C18:  BZ    0C1C
0C1A:  BC    0C92
0C1C:  BTFSC  54.7
0C1E:  BRA    0C92
0C20:  BTFSC  54.6
0C22:  BRA    0C2C
0C24:  MOVLW  20
0C26:  BRA    0C88
0C28:  MOVLW  20
0C2A:  ANDWF  54,F
0C2C:  BTFSS  54.5
0C2E:  BRA    0C4A
0C30:  BCF    54.5
0C32:  MOVF   53,W
0C34:  BTFSS  FD8.2
0C36:  DECF   54,F
0C38:  MOVF   00,W
0C3A:  MOVWF  54
0C3C:  MOVLW  2D
0C3E:  BTFSS  F9E.4
0C40:  BRA    0C3E
0C42:  MOVWF  FAD
0C44:  MOVF   54,W
0C46:  MOVWF  00
0C48:  CLRF   54
0C4A:  MOVF   53,W
0C4C:  SUBWF  56,W
0C4E:  BNZ   0C66
0C50:  MOVF   00,W
0C52:  MOVWF  54
0C54:  MOVLW  2E
0C56:  BTFSS  F9E.4
0C58:  BRA    0C56
0C5A:  MOVWF  FAD
0C5C:  MOVF   54,W
0C5E:  MOVWF  00
0C60:  MOVLW  20
0C62:  ANDWF  54,F
0C64:  MOVLW  00
0C66:  MOVLW  30
0C68:  BTFSS  54.5
0C6A:  BRA    0C88
0C6C:  BCF    54.5
0C6E:  MOVF   53,W
0C70:  BTFSS  FD8.2
0C72:  DECF   54,F
0C74:  MOVF   00,W
0C76:  MOVWF  54
0C78:  MOVLW  2D
0C7A:  BTFSS  F9E.4
0C7C:  BRA    0C7A
0C7E:  MOVWF  FAD
0C80:  MOVF   54,W
0C82:  MOVWF  00
0C84:  CLRF   54
0C86:  MOVLW  30
0C88:  ADDWF  00,F
0C8A:  MOVF   00,W
0C8C:  BTFSS  F9E.4
0C8E:  BRA    0C8C
0C90:  MOVWF  FAD
0C92:  BCF    FD8.1
0C94:  MOVFF  5B,60
0C98:  MOVFF  5A,5F
0C9C:  MOVFF  59,5E
0CA0:  MOVFF  58,5D
0CA4:  CLRF   x64
0CA6:  CLRF   x63
0CA8:  CLRF   x62
0CAA:  MOVLW  0A
0CAC:  MOVWF  x61
0CAE:  RCALL  0AB8
0CB0:  MOVFF  03,5B
0CB4:  MOVFF  02,5A
0CB8:  MOVFF  01,59
0CBC:  MOVFF  00,58
0CC0:  DECFSZ 56,F
0CC2:  BRA    0BDA
0CC4:  RETURN 0
*
0EA8:  MOVF   56,W
0EAA:  CLRF   01
0EAC:  SUBWF  55,W
0EAE:  BC    0EB6
0EB0:  MOVFF  55,00
0EB4:  BRA    0ECE
0EB6:  CLRF   00
0EB8:  MOVLW  08
0EBA:  MOVWF  57
0EBC:  RLCF   55,F
0EBE:  RLCF   00,F
0EC0:  MOVF   56,W
0EC2:  SUBWF  00,W
0EC4:  BTFSC  FD8.0
0EC6:  MOVWF  00
0EC8:  RLCF   01,F
0ECA:  DECFSZ 57,F
0ECC:  BRA    0EBC
0ECE:  RETURN 0
0ED0:  MOVF   01,W
0ED2:  MOVFF  53,55
0ED6:  MOVLW  64
0ED8:  MOVWF  56
0EDA:  RCALL  0EA8
0EDC:  MOVFF  00,53
0EE0:  MOVF   01,W
0EE2:  MOVLW  30
0EE4:  BNZ   0EF4
0EE6:  BTFSS  54.1
0EE8:  BRA    0F04
0EEA:  BTFSC  54.3
0EEC:  BRA    0F04
0EEE:  BTFSC  54.4
0EF0:  MOVLW  20
0EF2:  BRA    0EFA
0EF4:  BCF    54.3
0EF6:  BCF    54.4
0EF8:  BSF    54.0
0EFA:  ADDWF  01,F
0EFC:  MOVF   01,W
0EFE:  BTFSS  F9E.4
0F00:  BRA    0EFE
0F02:  MOVWF  FAD
0F04:  MOVFF  53,55
0F08:  MOVLW  0A
0F0A:  MOVWF  56
0F0C:  RCALL  0EA8
0F0E:  MOVFF  00,53
0F12:  MOVF   01,W
0F14:  MOVLW  30
0F16:  BNZ   0F24
0F18:  BTFSC  54.3
0F1A:  BRA    0F2E
0F1C:  BTFSS  54.0
0F1E:  BRA    0F2E
0F20:  BTFSC  54.4
0F22:  MOVLW  20
0F24:  ADDWF  01,F
0F26:  MOVF   01,W
0F28:  BTFSS  F9E.4
0F2A:  BRA    0F28
0F2C:  MOVWF  FAD
0F2E:  MOVLW  30
0F30:  ADDWF  53,F
0F32:  MOVF   53,W
0F34:  BTFSS  F9E.4
0F36:  BRA    0F34
0F38:  MOVWF  FAD
0F3A:  RETURN 0
0F3C:  MOVF   FE9,W
0F3E:  MOVWF  55
0F40:  MOVLW  3B
0F42:  MOVWF  5C
0F44:  MOVLW  9A
0F46:  MOVWF  5B
0F48:  MOVLW  CA
0F4A:  MOVWF  5A
0F4C:  CLRF   59
0F4E:  MOVLW  0A
0F50:  MOVWF  57
0F52:  BSF    FD8.1
0F54:  CLRF   FEA
0F56:  MOVLW  51
0F58:  MOVWF  FE9
0F5A:  MOVFF  54,60
0F5E:  MOVFF  53,5F
0F62:  MOVFF  52,5E
0F66:  MOVFF  51,5D
0F6A:  MOVFF  5C,64
0F6E:  MOVFF  5B,63
0F72:  MOVFF  5A,62
0F76:  MOVFF  59,61
0F7A:  RCALL  0AB8
0F7C:  MOVF   01,W
0F7E:  MOVF   00,F
0F80:  BNZ   0FA0
0F82:  MOVF   57,W
0F84:  XORLW  01
0F86:  BZ    0FA0
0F88:  MOVF   55,W
0F8A:  BZ    0FA2
0F8C:  ANDLW  0F
0F8E:  SUBWF  57,W
0F90:  BZ    0F94
0F92:  BC    0FAE
0F94:  BTFSC  55.7
0F96:  BRA    0FAE
0F98:  BTFSC  55.6
0F9A:  BRA    0FA2
0F9C:  MOVLW  20
0F9E:  BRA    0FA4
0FA0:  CLRF   55
0FA2:  MOVLW  30
0FA4:  ADDWF  00,F
0FA6:  MOVF   00,W
0FA8:  BTFSS  F9E.4
0FAA:  BRA    0FA8
0FAC:  MOVWF  FAD
0FAE:  BCF    FD8.1
0FB0:  MOVFF  5C,60
0FB4:  MOVFF  5B,5F
0FB8:  MOVFF  5A,5E
0FBC:  MOVFF  59,5D
0FC0:  CLRF   x64
0FC2:  CLRF   x63
0FC4:  CLRF   x62
0FC6:  MOVLW  0A
0FC8:  MOVWF  x61
0FCA:  RCALL  0AB8
0FCC:  MOVFF  03,5C
0FD0:  MOVFF  02,5B
0FD4:  MOVFF  01,5A
0FD8:  MOVFF  00,59
0FDC:  DECFSZ 57,F
0FDE:  BRA    0F52
0FE0:  RETURN 0
0FE2:  BTFSC  51.7
0FE4:  BRA    1006
0FE6:  MOVLW  0F
0FE8:  MOVWF  00
0FEA:  SWAPF  50,W
0FEC:  ANDWF  00,F
0FEE:  MOVLW  0A
0FF0:  SUBWF  00,W
0FF2:  BC    0FFA
0FF4:  MOVLW  30
0FF6:  ADDWF  00,F
0FF8:  BRA    0FFE
0FFA:  MOVF   51,W
0FFC:  ADDWF  00,F
0FFE:  MOVF   00,W
1000:  BTFSS  F9E.4
1002:  BRA    1000
1004:  MOVWF  FAD
1006:  MOVLW  0F
1008:  ANDWF  50,F
100A:  MOVLW  0A
100C:  SUBWF  50,W
100E:  BC    1014
1010:  MOVLW  30
1012:  BRA    1018
1014:  BCF    51.7
1016:  MOVF   51,W
1018:  ADDWF  50,F
101A:  MOVF   50,W
101C:  BTFSS  F9E.4
101E:  BRA    101C
1020:  MOVWF  FAD
1022:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses HS,NOPROTECT,NOLVP,NOWDT 
.................... #use delay(clock=20000000) 
*
046A:  CLRF   FEA
046C:  MOVLW  50
046E:  MOVWF  FE9
0470:  MOVF   FEF,W
0472:  BZ    048E
0474:  MOVLW  06
0476:  MOVWF  01
0478:  CLRF   00
047A:  DECFSZ 00,F
047C:  BRA    047A
047E:  DECFSZ 01,F
0480:  BRA    0478
0482:  MOVLW  7B
0484:  MOVWF  00
0486:  DECFSZ 00,F
0488:  BRA    0486
048A:  DECFSZ FEF,F
048C:  BRA    0474
048E:  RETURN 0
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7) 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specified message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transceiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ////  Jan 10 13 - updated can_init() function to setup correct tris  //// 
.................... ////              register for PIC being used.                       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive capture 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote transmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extended id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard identifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended identifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifier mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifier mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
038E:  MOVLW  04
0390:  MOVWF  4F
0392:  RCALL  020C
....................    can_set_baud(); 
0394:  BRA    022E
....................  
....................    RXB0CON=0; 
0396:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
0398:  MOVLW  9F
039A:  ANDWF  F60,W
039C:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
039E:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
03A0:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
03A4:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
03A6:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
03A8:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
03AA:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
03AC:  MOVLW  0F
03AE:  MOVWF  x60
03B0:  MOVLW  1B
03B2:  MOVWF  5F
03B4:  CLRF   x64
03B6:  CLRF   x63
03B8:  CLRF   x62
03BA:  CLRF   x61
03BC:  MOVLW  01
03BE:  MOVWF  x65
03C0:  RCALL  025E
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
03C2:  MOVLW  0F
03C4:  MOVWF  x60
03C6:  MOVLW  03
03C8:  MOVWF  5F
03CA:  CLRF   x64
03CC:  CLRF   x63
03CE:  CLRF   x62
03D0:  CLRF   x61
03D2:  MOVLW  01
03D4:  MOVWF  x65
03D6:  RCALL  025E
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
03D8:  MOVLW  0F
03DA:  MOVWF  x60
03DC:  MOVLW  07
03DE:  MOVWF  5F
03E0:  CLRF   x64
03E2:  CLRF   x63
03E4:  CLRF   x62
03E6:  CLRF   x61
03E8:  MOVLW  01
03EA:  MOVWF  x65
03EC:  RCALL  025E
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
03EE:  MOVLW  0F
03F0:  MOVWF  x60
03F2:  MOVLW  1F
03F4:  MOVWF  5F
03F6:  CLRF   x64
03F8:  CLRF   x63
03FA:  CLRF   x62
03FC:  CLRF   x61
03FE:  MOVLW  01
0400:  MOVWF  x65
0402:  RCALL  025E
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
0404:  MOVLW  0F
0406:  MOVWF  x60
0408:  MOVLW  0B
040A:  MOVWF  5F
040C:  CLRF   x64
040E:  CLRF   x63
0410:  CLRF   x62
0412:  CLRF   x61
0414:  MOVLW  01
0416:  MOVWF  x65
0418:  RCALL  025E
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
041A:  MOVLW  0F
041C:  MOVWF  x60
041E:  MOVWF  5F
0420:  CLRF   x64
0422:  CLRF   x63
0424:  CLRF   x62
0426:  CLRF   x61
0428:  MOVLW  01
042A:  MOVWF  x65
042C:  RCALL  025E
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
042E:  MOVLW  0F
0430:  MOVWF  x60
0432:  MOVLW  13
0434:  MOVWF  5F
0436:  CLRF   x64
0438:  CLRF   x63
043A:  CLRF   x62
043C:  CLRF   x61
043E:  MOVLW  01
0440:  MOVWF  x65
0442:  RCALL  025E
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
0444:  MOVLW  0F
0446:  MOVWF  x60
0448:  MOVLW  17
044A:  MOVWF  5F
044C:  CLRF   x64
044E:  CLRF   x63
0450:  CLRF   x62
0452:  CLRF   x61
0454:  MOVLW  01
0456:  MOVWF  x65
0458:  RCALL  025E
....................  
....................   #if (getenv("DEVICE") == "PIC18F6585") || (getenv("DEVICE") == "PIC18LF6585") || \ 
....................       (getenv("DEVICE") == "PIC18F6680") || (getenv("DEVICE") == "PIC18LF6680") || \ 
....................       (getenv("DEVICE") == "PIC18F8585") || (getenv("DEVICE") == "PIC18LF8585") || \ 
....................       (getenv("DEVICE") == "PIC18F8680") || (getenv("DEVICE") == "PIC18LF8680") || \ 
....................       (getenv("DEVICE") == "PIC18C658") || (getenv("DEVICE") == "PIC18C858") 
....................    set_tris_g((*getenv("SFR:TRISG") & 0xFE) | 0x04);  //G2 in, G0 out 
....................    if(CAN_ENABLE_CANTX2) 
....................     bit_clear(*getenv("SFR:TRISG"), 1);  //G1 out 
....................   #elif getenv("FUSE_SET:CANE") 
....................    set_tris_e((*getenv("SFR:TRISE") & 0xDF) | 0x10);  //E4 in, E5 out 
....................   #elif getenv("FUSE_SET:CANC") 
....................    set_tris_c((*getenv("SFR:TRISC") & 0xBF) | 0x80);  //C7 in, C6 out 
....................   #else 
....................    set_tris_b((*getenv("SFR:TRISB") & 0xFB) | 0x08);  //B3 in, B2 out 
045A:  MOVF   F93,W
045C:  ANDLW  FB
045E:  IORLW  08
0460:  MOVWF  F93
....................   #endif 
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
0462:  CLRF   4F
0464:  RCALL  020C
0466:  GOTO   117A (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
022E:  MOVLW  C0
0230:  ANDWF  F70,W
0232:  IORLW  04
0234:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
0236:  MOVLW  3F
0238:  ANDWF  F70,W
023A:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
023C:  MOVLW  F8
023E:  ANDWF  F71,W
0240:  IORLW  02
0242:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
0244:  MOVLW  C7
0246:  ANDWF  F71,W
0248:  IORLW  28
024A:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
024C:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
024E:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
0250:  MOVLW  F8
0252:  ANDWF  F72,W
0254:  IORLW  05
0256:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
0258:  BCF    F72.6
025A:  GOTO   0396 (RETURN)
.................... } 
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
020C:  SWAPF  4F,W
020E:  ANDLW  70
0210:  MOVWF  00
0212:  BCF    FD8.0
0214:  RLCF   00,F
0216:  MOVLW  1F
0218:  ANDWF  F6F,W
021A:  IORWF  00,W
021C:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
021E:  MOVFF  F6E,00
0222:  SWAPF  00,F
0224:  RRCF   00,W
0226:  ANDLW  07
0228:  SUBWF  4F,W
022A:  BNZ   021E
022C:  RETURN 0
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
025E:  MOVFF  60,67
0262:  MOVFF  5F,66
....................  
....................    if (ext) {  //extended 
0266:  MOVF   x65,F
0268:  BZ    030E
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
026A:  MOVFF  66,FE9
026E:  MOVFF  67,FEA
0272:  MOVFF  61,FEF
....................  
....................       //eidh 
....................       ptr--; 
0276:  MOVF   x66,W
0278:  BTFSC  FD8.2
027A:  DECF   x67,F
027C:  DECF   x66,F
....................       *ptr=make8(id,1); //8:15 
027E:  MOVFF  66,FE9
0282:  MOVFF  67,FEA
0286:  MOVFF  62,FEF
....................  
....................       //sidl 
....................       ptr--; 
028A:  MOVF   x66,W
028C:  BTFSC  FD8.2
028E:  DECF   x67,F
0290:  DECF   x66,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
0292:  MOVFF  66,FE9
0296:  MOVFF  67,FEA
029A:  MOVF   x63,W
029C:  ANDLW  03
029E:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
02A0:  MOVFF  66,FE9
02A4:  MOVFF  67,FEA
02A8:  MOVFF  63,00
02AC:  RLCF   00,F
02AE:  RLCF   00,F
02B0:  RLCF   00,F
02B2:  MOVLW  F8
02B4:  ANDWF  00,F
02B6:  MOVF   00,W
02B8:  ANDLW  E0
02BA:  IORWF  FEF,W
02BC:  MOVWF  FEF
....................       *ptr|=0x08; 
02BE:  MOVFF  66,FE9
02C2:  MOVFF  67,FEA
02C6:  MOVF   FEF,W
02C8:  IORLW  08
02CA:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
02CC:  MOVF   x66,W
02CE:  BTFSC  FD8.2
02D0:  DECF   x67,F
02D2:  DECF   x66,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
02D4:  MOVFF  66,FE9
02D8:  MOVFF  67,FEA
02DC:  MOVFF  63,00
02E0:  SWAPF  00,F
02E2:  RRCF   00,F
02E4:  MOVLW  07
02E6:  ANDWF  00,F
02E8:  MOVF   00,W
02EA:  ANDLW  07
02EC:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
02EE:  MOVFF  66,FE9
02F2:  MOVFF  67,FEA
02F6:  MOVFF  64,00
02FA:  RLCF   00,F
02FC:  RLCF   00,F
02FE:  RLCF   00,F
0300:  MOVLW  F8
0302:  ANDWF  00,F
0304:  MOVF   00,W
0306:  ANDLW  F8
0308:  IORWF  FEF,W
030A:  MOVWF  FEF
....................    } 
030C:  BRA    038C
....................    else {   //standard 
....................       //eidl 
....................       *ptr=0; 
030E:  MOVFF  66,FE9
0312:  MOVFF  67,FEA
0316:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
0318:  MOVF   x66,W
031A:  BTFSC  FD8.2
031C:  DECF   x67,F
031E:  DECF   x66,F
....................       *ptr=0; 
0320:  MOVFF  66,FE9
0324:  MOVFF  67,FEA
0328:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
032A:  MOVF   x66,W
032C:  BTFSC  FD8.2
032E:  DECF   x67,F
0330:  DECF   x66,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
0332:  MOVFF  66,FE9
0336:  MOVFF  67,FEA
033A:  MOVFF  61,00
033E:  SWAPF  00,F
0340:  RLCF   00,F
0342:  MOVLW  E0
0344:  ANDWF  00,F
0346:  MOVF   00,W
0348:  ANDLW  E0
034A:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
034C:  MOVF   x66,W
034E:  BTFSC  FD8.2
0350:  DECF   x67,F
0352:  DECF   x66,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
0354:  MOVFF  66,FE9
0358:  MOVFF  67,FEA
035C:  MOVFF  61,00
0360:  RRCF   00,F
0362:  RRCF   00,F
0364:  RRCF   00,F
0366:  MOVLW  1F
0368:  ANDWF  00,F
036A:  MOVF   00,W
036C:  ANDLW  1F
036E:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
0370:  MOVFF  66,FE9
0374:  MOVFF  67,FEA
0378:  MOVFF  62,00
037C:  SWAPF  00,F
037E:  RLCF   00,F
0380:  MOVLW  E0
0382:  ANDWF  00,F
0384:  MOVF   00,W
0386:  ANDLW  E0
0388:  IORWF  FEF,W
038A:  MOVWF  FEF
....................    } 
038C:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
*
0CC6:  CLRF   x61
0CC8:  CLRF   x60
0CCA:  CLRF   5F
0CCC:  CLRF   5E
....................    ptr=addr; 
0CCE:  MOVFF  5C,63
0CD2:  MOVFF  5B,62
....................  
....................    if (ext) { 
0CD6:  MOVF   5D,F
0CD8:  BTFSC  FD8.2
0CDA:  BRA    0DEE
....................       ret=*ptr;  //eidl 
0CDC:  MOVFF  62,FE9
0CE0:  MOVFF  63,FEA
0CE4:  CLRF   x61
0CE6:  CLRF   x60
0CE8:  CLRF   5F
0CEA:  MOVFF  FEF,5E
....................  
....................       ptr--;     //eidh 
0CEE:  MOVF   x62,W
0CF0:  BTFSC  FD8.2
0CF2:  DECF   x63,F
0CF4:  DECF   x62,F
....................       ret|=((unsigned int32)*ptr << 8); 
0CF6:  MOVFF  62,FE9
0CFA:  MOVFF  63,FEA
0CFE:  MOVF   FEF,W
0D00:  CLRF   x66
0D02:  CLRF   x65
0D04:  MOVWF  x64
0D06:  CLRF   00
0D08:  MOVF   00,W
0D0A:  IORWF  5E,F
0D0C:  MOVF   x64,W
0D0E:  IORWF  5F,F
0D10:  MOVF   x65,W
0D12:  IORWF  x60,F
0D14:  MOVF   x66,W
0D16:  IORWF  x61,F
....................  
....................       ptr--;     //sidl 
0D18:  MOVF   x62,W
0D1A:  BTFSC  FD8.2
0D1C:  DECF   x63,F
0D1E:  DECF   x62,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
0D20:  MOVFF  62,FE9
0D24:  MOVFF  63,FEA
0D28:  MOVF   FEF,W
0D2A:  CLRF   x67
0D2C:  CLRF   x66
0D2E:  CLRF   x65
0D30:  MOVWF  x64
0D32:  MOVLW  03
0D34:  ANDWF  x64,F
0D36:  CLRF   x65
0D38:  CLRF   x66
0D3A:  CLRF   x67
0D3C:  CLRF   00
0D3E:  CLRF   01
0D40:  MOVF   00,W
0D42:  IORWF  5E,F
0D44:  MOVF   01,W
0D46:  IORWF  5F,F
0D48:  MOVF   x64,W
0D4A:  IORWF  x60,F
0D4C:  MOVF   x65,W
0D4E:  IORWF  x61,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
0D50:  MOVFF  62,FE9
0D54:  MOVFF  63,FEA
0D58:  MOVF   FEF,W
0D5A:  CLRF   x67
0D5C:  CLRF   x66
0D5E:  CLRF   x65
0D60:  MOVWF  x64
0D62:  MOVLW  E0
0D64:  ANDWF  x64,F
0D66:  CLRF   x65
0D68:  CLRF   x66
0D6A:  CLRF   x67
0D6C:  CLRF   00
0D6E:  RLCF   x64,W
0D70:  MOVWF  01
0D72:  RLCF   x65,W
0D74:  MOVWF  02
0D76:  RLCF   x66,W
0D78:  MOVWF  03
0D7A:  RLCF   01,F
0D7C:  RLCF   02,F
0D7E:  RLCF   03,F
0D80:  RLCF   01,F
0D82:  RLCF   02,F
0D84:  RLCF   03,F
0D86:  RLCF   01,F
0D88:  RLCF   02,F
0D8A:  RLCF   03,F
0D8C:  RLCF   01,F
0D8E:  RLCF   02,F
0D90:  RLCF   03,F
0D92:  MOVLW  E0
0D94:  ANDWF  01,F
0D96:  MOVF   00,W
0D98:  IORWF  5E,F
0D9A:  MOVF   01,W
0D9C:  IORWF  5F,F
0D9E:  MOVF   02,W
0DA0:  IORWF  x60,F
0DA2:  MOVF   03,W
0DA4:  IORWF  x61,F
....................  
....................       ptr--;     //sidh 
0DA6:  MOVF   x62,W
0DA8:  BTFSC  FD8.2
0DAA:  DECF   x63,F
0DAC:  DECF   x62,F
....................       ret|=((unsigned int32)*ptr << 21); 
0DAE:  MOVFF  62,FE9
0DB2:  MOVFF  63,FEA
0DB6:  MOVF   FEF,W
0DB8:  CLRF   x65
0DBA:  MOVWF  x64
0DBC:  CLRF   00
0DBE:  CLRF   01
0DC0:  RLCF   x64,W
0DC2:  MOVWF  02
0DC4:  RLCF   x65,W
0DC6:  MOVWF  03
0DC8:  RLCF   02,F
0DCA:  RLCF   03,F
0DCC:  RLCF   02,F
0DCE:  RLCF   03,F
0DD0:  RLCF   02,F
0DD2:  RLCF   03,F
0DD4:  RLCF   02,F
0DD6:  RLCF   03,F
0DD8:  MOVLW  E0
0DDA:  ANDWF  02,F
0DDC:  MOVF   00,W
0DDE:  IORWF  5E,F
0DE0:  MOVF   01,W
0DE2:  IORWF  5F,F
0DE4:  MOVF   02,W
0DE6:  IORWF  x60,F
0DE8:  MOVF   03,W
0DEA:  IORWF  x61,F
....................  
....................    } 
0DEC:  BRA    0E94
....................    else { 
....................       ptr-=2;    //sidl 
0DEE:  MOVLW  02
0DF0:  SUBWF  x62,F
0DF2:  MOVLW  00
0DF4:  SUBWFB x63,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
0DF6:  MOVFF  62,FE9
0DFA:  MOVFF  63,FEA
0DFE:  MOVF   FEF,W
0E00:  CLRF   x67
0E02:  CLRF   x66
0E04:  CLRF   x65
0E06:  MOVWF  x64
0E08:  MOVLW  E0
0E0A:  ANDWF  x64,F
0E0C:  CLRF   x65
0E0E:  CLRF   x66
0E10:  CLRF   x67
0E12:  RRCF   x67,W
0E14:  MOVWF  x61
0E16:  RRCF   x66,W
0E18:  MOVWF  x60
0E1A:  RRCF   x65,W
0E1C:  MOVWF  5F
0E1E:  RRCF   x64,W
0E20:  MOVWF  5E
0E22:  RRCF   x61,F
0E24:  RRCF   x60,F
0E26:  RRCF   5F,F
0E28:  RRCF   5E,F
0E2A:  RRCF   x61,F
0E2C:  RRCF   x60,F
0E2E:  RRCF   5F,F
0E30:  RRCF   5E,F
0E32:  RRCF   x61,F
0E34:  RRCF   x60,F
0E36:  RRCF   5F,F
0E38:  RRCF   5E,F
0E3A:  RRCF   x61,F
0E3C:  RRCF   x60,F
0E3E:  RRCF   5F,F
0E40:  RRCF   5E,F
0E42:  MOVLW  07
0E44:  ANDWF  x61,F
....................  
....................       ptr--;     //sidh 
0E46:  MOVF   x62,W
0E48:  BTFSC  FD8.2
0E4A:  DECF   x63,F
0E4C:  DECF   x62,F
....................       ret|=((unsigned int32)*ptr << 3); 
0E4E:  MOVFF  62,FE9
0E52:  MOVFF  63,FEA
0E56:  MOVF   FEF,W
0E58:  CLRF   x67
0E5A:  CLRF   x66
0E5C:  CLRF   x65
0E5E:  MOVWF  x64
0E60:  RLCF   x64,W
0E62:  MOVWF  00
0E64:  RLCF   x65,W
0E66:  MOVWF  01
0E68:  RLCF   x66,W
0E6A:  MOVWF  02
0E6C:  RLCF   x67,W
0E6E:  MOVWF  03
0E70:  RLCF   00,F
0E72:  RLCF   01,F
0E74:  RLCF   02,F
0E76:  RLCF   03,F
0E78:  RLCF   00,F
0E7A:  RLCF   01,F
0E7C:  RLCF   02,F
0E7E:  RLCF   03,F
0E80:  MOVLW  F8
0E82:  ANDWF  00,F
0E84:  MOVF   00,W
0E86:  IORWF  5E,F
0E88:  MOVF   01,W
0E8A:  IORWF  5F,F
0E8C:  MOVF   02,W
0E8E:  IORWF  x60,F
0E90:  MOVF   03,W
0E92:  IORWF  x61,F
....................    } 
....................  
....................    return(ret); 
0E94:  MOVFF  5E,00
0E98:  MOVFF  5F,01
0E9C:  MOVFF  60,02
0EA0:  MOVFF  61,03
0EA4:  GOTO   15E8 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Parameters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
1024:  MOVLW  0F
1026:  MOVWF  5D
1028:  MOVLW  66
102A:  MOVWF  5C
....................  
....................     // find empty transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
102C:  MOVLB  F
102E:  BTFSC  x40.3
1030:  BRA    103E
....................       CANCON.win=CAN_WIN_TX0; 
1032:  MOVLW  F1
1034:  ANDWF  F6F,W
1036:  IORLW  08
1038:  MOVWF  F6F
....................       port=0; 
103A:  CLRF   5E
....................    } 
103C:  BRA    1068
....................    else if (!TXB1CON.txreq) { 
103E:  BTFSC  x30.3
1040:  BRA    1050
....................       CANCON.win=CAN_WIN_TX1; 
1042:  MOVLW  F1
1044:  ANDWF  F6F,W
1046:  IORLW  06
1048:  MOVWF  F6F
....................       port=1; 
104A:  MOVLW  01
104C:  MOVWF  5E
....................    } 
104E:  BRA    1068
....................    else if (!TXB2CON.txreq) { 
1050:  BTFSC  x20.3
1052:  BRA    1062
....................       CANCON.win=CAN_WIN_TX2; 
1054:  MOVLW  F1
1056:  ANDWF  F6F,W
1058:  IORLW  04
105A:  MOVWF  F6F
....................       port=2; 
105C:  MOVLW  02
105E:  MOVWF  5E
....................    } 
1060:  BRA    1068
....................    else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
1062:  MOVLW  00
1064:  MOVWF  01
1066:  BRA    10E0
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
1068:  MOVF   58,W
106A:  ANDLW  03
106C:  MOVWF  00
106E:  MOVLW  FC
1070:  ANDWF  F60,W
1072:  IORWF  00,W
1074:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
1076:  MOVLW  0F
1078:  MOVLB  0
107A:  MOVWF  x60
107C:  MOVLW  64
107E:  MOVWF  5F
1080:  MOVFF  54,64
1084:  MOVFF  53,63
1088:  MOVFF  52,62
108C:  MOVFF  51,61
1090:  MOVFF  59,65
1094:  CALL   025E
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
1098:  MOVFF  57,F65
....................    TXBaDLC.rtr=rtr; 
109C:  BCF    F65.6
109E:  BTFSC  5A.0
10A0:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
10A2:  CLRF   5B
10A4:  MOVF   57,W
10A6:  SUBWF  5B,W
10A8:  BC    10D2
....................       *txd0=*data; 
10AA:  MOVFF  55,FE9
10AE:  MOVFF  56,FEA
10B2:  MOVFF  FEF,61
10B6:  MOVFF  5D,FEA
10BA:  MOVFF  5C,FE9
10BE:  MOVFF  61,FEF
....................       txd0++; 
10C2:  INCF   5C,F
10C4:  BTFSC  FD8.2
10C6:  INCF   5D,F
....................       data++; 
10C8:  INCF   55,F
10CA:  BTFSC  FD8.2
10CC:  INCF   56,F
10CE:  INCF   5B,F
10D0:  BRA    10A4
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
10D2:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
10D4:  MOVLW  F1
10D6:  ANDWF  F6F,W
10D8:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
10DA:  MOVLW  01
10DC:  MOVWF  01
10DE:  MOVLB  F
10E0:  MOVLB  0
10E2:  GOTO   183A (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             received it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
1554:  BTFSS  F60.7
1556:  BRA    1586
....................         CANCON.win=CAN_WIN_RX0; 
1558:  MOVLW  F1
155A:  ANDWF  F6F,W
155C:  MOVWF  F6F
....................         stat.buffer=0; 
155E:  BCF    21.4
....................  
....................         CAN_INT_RXB0IF=0; 
1560:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
1562:  BCF    21.0
1564:  BTFSC  F74.7
1566:  BSF    21.0
....................         COMSTAT.rx0ovfl=0; 
1568:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
156A:  BTFSS  F60.2
156C:  BRA    1584
....................          stat.filthit=RXB0CON.filthit0; 
156E:  MOVLW  00
1570:  BTFSC  F60.0
1572:  MOVLW  01
1574:  ANDLW  07
1576:  MOVWF  00
1578:  BCF    FD8.0
157A:  RLCF   00,F
157C:  MOVLW  F1
157E:  ANDWF  21,W
1580:  IORWF  00,W
1582:  MOVWF  21
....................         } 
....................     } 
1584:  BRA    15BE
....................     else if ( RXB1CON.rxful ) 
1586:  MOVLB  F
1588:  BTFSS  x50.7
158A:  BRA    15B6
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
158C:  MOVLW  F1
158E:  ANDWF  F6F,W
1590:  IORLW  0A
1592:  MOVWF  F6F
....................         stat.buffer=1; 
1594:  BSF    21.4
....................  
....................         CAN_INT_RXB1IF=0; 
1596:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
1598:  BCF    21.0
159A:  BTFSC  F74.6
159C:  BSF    21.0
....................         COMSTAT.rx1ovfl=0; 
159E:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
15A0:  MOVF   x50,W
15A2:  ANDLW  07
15A4:  ANDLW  07
15A6:  MOVWF  00
15A8:  BCF    FD8.0
15AA:  RLCF   00,F
15AC:  MOVLW  F1
15AE:  ANDWF  21,W
15B0:  IORWF  00,W
15B2:  MOVWF  21
....................     } 
15B4:  BRA    15BC
....................     else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
15B6:  MOVLW  00
15B8:  MOVWF  01
15BA:  BRA    1652
15BC:  MOVLB  0
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
15BE:  MOVF   F65,W
15C0:  ANDLW  0F
15C2:  MOVWF  2E
....................     stat.rtr=RXBaDLC.rtr; 
15C4:  BCF    21.5
15C6:  BTFSC  F65.6
15C8:  BSF    21.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
15CA:  BCF    21.6
15CC:  BTFSC  F62.3
15CE:  BSF    21.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
15D0:  MOVLW  00
15D2:  BTFSC  21.6
15D4:  MOVLW  01
15D6:  MOVWF  54
15D8:  MOVLW  0F
15DA:  MOVWF  5C
15DC:  MOVLW  64
15DE:  MOVWF  5B
15E0:  MOVFF  54,5D
15E4:  GOTO   0CC6
15E8:  MOVFF  03,25
15EC:  MOVFF  02,24
15F0:  MOVFF  01,23
15F4:  MOVFF  00,22
....................  
....................     ptr = &TXRXBaD0; 
15F8:  MOVLW  0F
15FA:  MOVWF  53
15FC:  MOVLW  66
15FE:  MOVWF  52
....................     for ( i = 0; i < len; i++ ) { 
1600:  CLRF   51
1602:  MOVF   2E,W
1604:  SUBWF  51,W
1606:  BC    1630
....................         *data = *ptr; 
1608:  MOVFF  52,FE9
160C:  MOVFF  53,FEA
1610:  MOVFF  FEF,56
1614:  MOVFF  50,FEA
1618:  MOVFF  4F,FE9
161C:  MOVFF  56,FEF
....................         data++; 
1620:  INCF   4F,F
1622:  BTFSC  FD8.2
1624:  INCF   50,F
....................         ptr++; 
1626:  INCF   52,F
1628:  BTFSC  FD8.2
162A:  INCF   53,F
162C:  INCF   51,F
162E:  BRA    1602
....................     } 
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
1630:  MOVLW  F1
1632:  ANDWF  F6F,W
1634:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
1636:  BCF    21.7
1638:  BTFSC  FA4.7
163A:  BSF    21.7
....................     CAN_INT_IRXIF = 0; 
163C:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
163E:  BTFSS  21.4
1640:  BRA    164A
....................       RXB1CON.rxful=0; 
1642:  MOVLB  F
1644:  BCF    x50.7
....................     } 
1646:  BRA    164E
1648:  MOVLB  0
....................     else { 
....................       RXB0CON.rxful=0; 
164A:  BCF    F60.7
164C:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
164E:  MOVLW  01
1650:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
.................... //#include <BME280.c> 
.................... #include <sht71.c> 
.................... // Driver file for SHT75 Temperature & Humidity Sensor                       //  
.................... //                                                                           //  
.................... // ***** To initialise SHT75 sensor upon power up *****                      //  
.................... //                                                                           //  
.................... // Function : sht_init()                                                     //  
.................... // Return   : none                                                           //  
.................... //                                                                           //  
.................... //                                                                           //  
.................... // ***** To measure and caluculate SHT75 temp & real RH *****                //  
.................... //                                                                           //  
.................... // Function : sht_rd (temp, truehumid)                                       //  
.................... // Return   : temperature & true humidity in float values                    //  
.................... //                                                                           //  
.................... ///////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define sht_data_pin   PIN_B7  // cu cua pic16f887 la PIN_D7 
.................... #define sht_clk_pin    PIN_B6  // cu cua pic16f887 la PIN_D6 
....................  
....................  
.................... //***** Function to alert SHT75 *****  
....................  
.................... void comstart (void)  
.................... {  
....................  output_float(sht_data_pin);  //data high  
*
0490:  BSF    F93.7
....................  output_bit(sht_clk_pin, 0);  //clk low  
0492:  BCF    F8A.6
0494:  BCF    F93.6
....................  delay_us(1);  
0496:  BRA    0498
0498:  BRA    049A
049A:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
049C:  BSF    F8A.6
049E:  BCF    F93.6
....................  delay_us(1);  
04A0:  BRA    04A2
04A2:  BRA    04A4
04A4:  NOP   
....................  output_bit(sht_data_pin, 0); //data low  
04A6:  BCF    F8A.7
04A8:  BCF    F93.7
....................  delay_us(1);  
04AA:  BRA    04AC
04AC:  BRA    04AE
04AE:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
04B0:  BCF    F8A.6
04B2:  BCF    F93.6
....................  delay_us(2);  
04B4:  MOVLW  02
04B6:  MOVWF  00
04B8:  DECFSZ 00,F
04BA:  BRA    04B8
04BC:  BRA    04BE
04BE:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
04C0:  BSF    F8A.6
04C2:  BCF    F93.6
....................  delay_us(1);  
04C4:  BRA    04C6
04C6:  BRA    04C8
04C8:  NOP   
....................  output_float(sht_data_pin);  //data high  
04CA:  BSF    F93.7
....................  delay_us(1);  
04CC:  BRA    04CE
04CE:  BRA    04D0
04D0:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
04D2:  BCF    F8A.6
04D4:  BCF    F93.6
04D6:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to write data to SHT75 *****  
....................  
.................... int1 comwrite (int8 iobyte)  
*
0528:  MOVLW  80
052A:  MOVWF  x64
.................... {  
....................  int8 i, mask = 0x80;  
....................  int1 ack;  
....................  
....................  //Shift out command  
....................  delay_us(4);  
052C:  MOVLW  06
052E:  MOVWF  00
0530:  DECFSZ 00,F
0532:  BRA    0530
0534:  NOP   
....................  for(i=0; i<8; i++)  
0536:  CLRF   x63
0538:  MOVF   x63,W
053A:  SUBLW  07
053C:  BNC   0568
....................   {  
....................    output_bit(sht_clk_pin, 0);                          //clk low  
053E:  BCF    F8A.6
0540:  BCF    F93.6
....................    if((iobyte & mask) > 0) output_float(sht_data_pin);  //data high if MSB high  
0542:  MOVF   x62,W
0544:  ANDWF  x64,W
0546:  BZ    054C
0548:  BSF    F93.7
054A:  BRA    0550
....................    else output_bit(sht_data_pin, 0);                    //data low if MSB low  
054C:  BCF    F8A.7
054E:  BCF    F93.7
....................    delay_us(1);  
0550:  BRA    0552
0552:  BRA    0554
0554:  NOP   
....................    output_bit(sht_clk_pin, 1);                          //clk high  
0556:  BSF    F8A.6
0558:  BCF    F93.6
....................    delay_us(1);  
055A:  BRA    055C
055C:  BRA    055E
055E:  NOP   
....................    mask = mask >> 1;                                    //shift to next bit  
0560:  BCF    FD8.0
0562:  RRCF   x64,F
0564:  INCF   x63,F
0566:  BRA    0538
....................   }  
....................  
....................  //Shift in ack  
....................  output_bit(sht_clk_pin, 0);  //clk low  
0568:  BCF    F8A.6
056A:  BCF    F93.6
....................  delay_us(1);  
056C:  BRA    056E
056E:  BRA    0570
0570:  NOP   
....................  ack = input(sht_data_pin);   //get ack bit  
0572:  BSF    F93.7
0574:  BCF    x65.0
0576:  BTFSC  F81.7
0578:  BSF    x65.0
....................  output_bit(sht_clk_pin, 1);  //clk high  
057A:  BSF    F8A.6
057C:  BCF    F93.6
....................  delay_us(1);  
057E:  BRA    0580
0580:  BRA    0582
0582:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
0584:  BCF    F8A.6
0586:  BCF    F93.6
....................  return(ack);  
0588:  MOVLW  00
058A:  BTFSC  x65.0
058C:  MOVLW  01
058E:  MOVWF  01
0590:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to read data from SHT75 *****  
....................  
.................... int16 comread (void)  
*
05CA:  CLRF   x64
05CC:  CLRF   x63
.................... {  
....................  int8 i;  
....................  int16 iobyte = 0;  
....................  const int16 mask0 = 0x0000;  
....................  const int16 mask1 = 0x0001;  
....................  
....................  //shift in MSB data  
....................  for(i=0; i<8; i++)  
05CE:  CLRF   x62
05D0:  MOVF   x62,W
05D2:  SUBLW  07
05D4:  BNC   05FC
....................   {  
....................    iobyte = iobyte << 1;  
05D6:  BCF    FD8.0
05D8:  RLCF   x63,F
05DA:  RLCF   x64,F
....................    output_bit(sht_clk_pin, 1);                //clk high  
05DC:  BSF    F8A.6
05DE:  BCF    F93.6
....................    delay_us(1);  
05E0:  BRA    05E2
05E2:  BRA    05E4
05E4:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit  
05E6:  BSF    F93.7
05E8:  BTFSS  F81.7
05EA:  BRA    05EE
05EC:  BSF    x63.0
....................    else iobyte |= mask0;  
....................    output_bit(sht_clk_pin, 0);                //clk low  
05EE:  BCF    F8A.6
05F0:  BCF    F93.6
....................    delay_us(1);  
05F2:  BRA    05F4
05F4:  BRA    05F6
05F6:  NOP   
05F8:  INCF   x62,F
05FA:  BRA    05D0
....................   }  
....................  
....................  //send ack 0 bit  
....................  output_bit(sht_data_pin, 0); //data low  
05FC:  BCF    F8A.7
05FE:  BCF    F93.7
....................  delay_us(1);  
0600:  BRA    0602
0602:  BRA    0604
0604:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
0606:  BSF    F8A.6
0608:  BCF    F93.6
....................  delay_us(2);  
060A:  MOVLW  02
060C:  MOVWF  00
060E:  DECFSZ 00,F
0610:  BRA    060E
0612:  BRA    0614
0614:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
0616:  BCF    F8A.6
0618:  BCF    F93.6
....................  delay_us(1);  
061A:  BRA    061C
061C:  BRA    061E
061E:  NOP   
....................  output_float(sht_data_pin);  //data high  
0620:  BSF    F93.7
....................  
....................  //shift in LSB data  
....................  for(i=0; i<8; i++)  
0622:  CLRF   x62
0624:  MOVF   x62,W
0626:  SUBLW  07
0628:  BNC   0650
....................   {  
....................    iobyte = iobyte << 1;  
062A:  BCF    FD8.0
062C:  RLCF   x63,F
062E:  RLCF   x64,F
....................    output_bit(sht_clk_pin, 1);                //clk high  
0630:  BSF    F8A.6
0632:  BCF    F93.6
....................    delay_us(1);  
0634:  BRA    0636
0636:  BRA    0638
0638:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit  
063A:  BSF    F93.7
063C:  BTFSS  F81.7
063E:  BRA    0642
0640:  BSF    x63.0
....................    else iobyte |= mask0;  
....................    output_bit(sht_clk_pin, 0);                //clk low  
0642:  BCF    F8A.6
0644:  BCF    F93.6
....................    delay_us(1);  
0646:  BRA    0648
0648:  BRA    064A
064A:  NOP   
064C:  INCF   x62,F
064E:  BRA    0624
....................   }  
....................  
....................  //send ack 1 bit  
....................  output_float(sht_data_pin);  //data high  
0650:  BSF    F93.7
....................  delay_us(1);  
0652:  BRA    0654
0654:  BRA    0656
0656:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
0658:  BSF    F8A.6
065A:  BCF    F93.6
....................  delay_us(2);  
065C:  MOVLW  02
065E:  MOVWF  00
0660:  DECFSZ 00,F
0662:  BRA    0660
0664:  BRA    0666
0666:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
0668:  BCF    F8A.6
066A:  BCF    F93.6
....................  
....................  return(iobyte);  
066C:  MOVFF  63,01
0670:  MOVFF  64,02
0674:  RETURN 0
.................... }  
....................  
.................... //***** Function to wait for SHT75 reading *****  
....................  
.................... void comwait (void)  
.................... {  
....................  int16 sht_delay;  
....................  
....................  output_float(sht_data_pin);                     //data high  
*
0592:  BSF    F93.7
....................  output_bit(sht_clk_pin, 0);                     //clk low  
0594:  BCF    F8A.6
0596:  BCF    F93.6
....................  delay_us(1);  
0598:  BRA    059A
059A:  BRA    059C
059C:  NOP   
....................  for(sht_delay=0; sht_delay<30000; sht_delay++)  // wait for max 300ms  
059E:  CLRF   x63
05A0:  CLRF   x62
05A2:  MOVF   x63,W
05A4:  SUBLW  75
05A6:  BNC   05C8
05A8:  BNZ   05B0
05AA:  MOVF   x62,W
05AC:  SUBLW  2F
05AE:  BNC   05C8
....................   {  
....................    if (!input(sht_data_pin)) break;              //if sht_data_pin low, SHT75 ready  
05B0:  BSF    F93.7
05B2:  BTFSS  F81.7
05B4:  BRA    05C8
....................    delay_us(10);  
05B6:  MOVLW  10
05B8:  MOVWF  00
05BA:  DECFSZ 00,F
05BC:  BRA    05BA
05BE:  NOP   
05C0:  INCF   x62,F
05C2:  BTFSC  FD8.2
05C4:  INCF   x63,F
05C6:  BRA    05A2
....................   }  
05C8:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to reset SHT75 communication *****  
....................  
....................  
.................... void comreset (void)  
.................... {  
....................  int8 i;  
....................  
....................  output_float(sht_data_pin);    //data high  
*
04D8:  BSF    F93.7
....................  output_bit(sht_clk_pin, 0);    //clk low  
04DA:  BCF    F8A.6
04DC:  BCF    F93.6
....................  delay_us(2);  
04DE:  MOVLW  02
04E0:  MOVWF  00
04E2:  DECFSZ 00,F
04E4:  BRA    04E2
04E6:  BRA    04E8
04E8:  NOP   
....................  for(i=0; i<9; i++)  
04EA:  CLRF   4F
04EC:  MOVF   4F,W
04EE:  SUBLW  08
04F0:  BNC   0516
....................   {  
....................    output_bit(sht_clk_pin, 1);  //toggle clk 9 times  
04F2:  BSF    F8A.6
04F4:  BCF    F93.6
....................    delay_us(2);  
04F6:  MOVLW  02
04F8:  MOVWF  00
04FA:  DECFSZ 00,F
04FC:  BRA    04FA
04FE:  BRA    0500
0500:  NOP   
....................    output_bit(sht_clk_pin, 0);  
0502:  BCF    F8A.6
0504:  BCF    F93.6
....................    delay_us(2);  
0506:  MOVLW  02
0508:  MOVWF  00
050A:  DECFSZ 00,F
050C:  BRA    050A
050E:  BRA    0510
0510:  NOP   
0512:  INCF   4F,F
0514:  BRA    04EC
....................  }  
....................  comstart();  
0516:  RCALL  0490
0518:  GOTO   051E (RETURN)
.................... }  
....................  
....................  
.................... //***** Function to soft reset SHT75 *****  
....................  
.................... void sht_soft_reset (void)  
.................... {  
....................  comreset();           //SHT75 communication reset  
....................  comwrite(0x1e);       //send SHT75 reset command  
....................  delay_ms(15);         //pause 15 ms  
.................... }  
....................  
....................  
.................... //***** Function to measure SHT75 temperature *****  
....................  
.................... int16 measuretemp()  
.................... {  
....................  int1 ack;  
....................  int16 iobyte;  
....................  
....................  comstart();             //alert SHT75  
*
0676:  RCALL  0490
....................  ack = comwrite(0x03);   //send measure temp command and read ack status  
0678:  MOVLW  03
067A:  MOVWF  x62
067C:  RCALL  0528
067E:  BCF    5F.0
0680:  BTFSC  01.0
0682:  BSF    5F.0
....................  if(ack == 1) return;  
0684:  BTFSC  5F.0
0686:  BRA    069C
....................  comwait();              //wait for SHT75 measurement to complete  
0688:  RCALL  0592
....................  iobyte = comread();     //read SHT75 temp data  
068A:  RCALL  05CA
068C:  MOVFF  02,61
0690:  MOVFF  01,60
....................  return(iobyte);  
0694:  MOVFF  60,01
0698:  MOVFF  61,02
069C:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to measure SHT75 RH *****  
....................  
.................... int16 measurehumid (void)  
.................... {  
....................  int1 ack;  
....................  int16 iobyte;  
....................  
....................  comstart();            //alert SHT75  
*
06D4:  RCALL  0490
....................  ack = comwrite(0x05);  //send measure RH command and read ack status  
06D6:  MOVLW  05
06D8:  MOVWF  x62
06DA:  RCALL  0528
06DC:  BCF    5F.0
06DE:  BTFSC  01.0
06E0:  BSF    5F.0
....................  if(ack == 1) return;  
06E2:  BTFSC  5F.0
06E4:  BRA    06FA
....................  comwait();             //wait for SHT75 measurement to complete  
06E6:  RCALL  0592
....................  iobyte = comread();    //read SHT75 temp data  
06E8:  RCALL  05CA
06EA:  MOVFF  02,61
06EE:  MOVFF  01,60
....................  return(iobyte);  
06F2:  MOVFF  60,01
06F6:  MOVFF  61,02
06FA:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to calculate SHT75 temp & RH *****  
....................  
.................... void calculate_data (int16 temp, int16 humid, float & tc, float & rhlin, float & rhtrue)  
.................... {  
....................  float rh;  
....................  
....................  //calculate temperature reading  
....................  tc = ((float) temp * 0.01) - 40.0;  
*
1214:  MOVFF  60,74
1218:  MOVFF  5F,73
121C:  CALL   069E
1220:  MOVFF  03,6A
1224:  MOVFF  02,69
1228:  MOVFF  01,68
122C:  MOVFF  00,67
1230:  MOVFF  03,7E
1234:  MOVFF  02,7D
1238:  MOVFF  01,7C
123C:  MOVFF  00,7B
1240:  MOVLW  0A
1242:  MOVWF  x82
1244:  MOVLW  D7
1246:  MOVWF  x81
1248:  MOVLW  23
124A:  MOVWF  x80
124C:  MOVLW  78
124E:  MOVWF  x7F
1250:  CALL   06FC
1254:  MOVFF  03,6A
1258:  MOVFF  02,69
125C:  MOVFF  01,68
1260:  MOVFF  00,67
1264:  BSF    FD8.1
1266:  MOVFF  03,7A
126A:  MOVFF  02,79
126E:  MOVFF  01,78
1272:  MOVFF  00,77
1276:  CLRF   x7E
1278:  CLRF   x7D
127A:  MOVLW  20
127C:  MOVWF  x7C
127E:  MOVLW  84
1280:  MOVWF  x7B
1282:  CALL   07EE
1286:  MOVFF  03,4A
128A:  MOVFF  02,49
128E:  MOVFF  01,48
1292:  MOVFF  00,47
....................  
....................  //calculate Real RH reading  
....................  rh = (float) humid;  
1296:  MOVFF  62,74
129A:  MOVFF  61,73
129E:  CALL   069E
12A2:  MOVFF  03,66
12A6:  MOVFF  02,65
12AA:  MOVFF  01,64
12AE:  MOVFF  00,63
....................  
....................  rhlin = (rh * 0.0405) - (rh * rh * 0.0000028) - 4.0;  
12B2:  MOVFF  66,7E
12B6:  MOVFF  65,7D
12BA:  MOVFF  64,7C
12BE:  MOVFF  63,7B
12C2:  MOVLW  54
12C4:  MOVWF  x82
12C6:  MOVLW  E3
12C8:  MOVWF  x81
12CA:  MOVLW  25
12CC:  MOVWF  x80
12CE:  MOVLW  7A
12D0:  MOVWF  x7F
12D2:  CALL   06FC
12D6:  MOVFF  03,6A
12DA:  MOVFF  02,69
12DE:  MOVFF  01,68
12E2:  MOVFF  00,67
12E6:  MOVFF  66,7E
12EA:  MOVFF  65,7D
12EE:  MOVFF  64,7C
12F2:  MOVFF  63,7B
12F6:  MOVFF  66,82
12FA:  MOVFF  65,81
12FE:  MOVFF  64,80
1302:  MOVFF  63,7F
1306:  CALL   06FC
130A:  MOVFF  03,6E
130E:  MOVFF  02,6D
1312:  MOVFF  01,6C
1316:  MOVFF  00,6B
131A:  MOVFF  03,7E
131E:  MOVFF  02,7D
1322:  MOVFF  01,7C
1326:  MOVFF  00,7B
132A:  MOVLW  A2
132C:  MOVWF  x82
132E:  MOVLW  E7
1330:  MOVWF  x81
1332:  MOVLW  3B
1334:  MOVWF  x80
1336:  MOVLW  6C
1338:  MOVWF  x7F
133A:  CALL   06FC
133E:  BSF    FD8.1
1340:  MOVFF  6A,7A
1344:  MOVFF  69,79
1348:  MOVFF  68,78
134C:  MOVFF  67,77
1350:  MOVFF  03,7E
1354:  MOVFF  02,7D
1358:  MOVFF  01,7C
135C:  MOVFF  00,7B
1360:  CALL   07EE
1364:  MOVFF  03,6A
1368:  MOVFF  02,69
136C:  MOVFF  01,68
1370:  MOVFF  00,67
1374:  BSF    FD8.1
1376:  MOVFF  03,7A
137A:  MOVFF  02,79
137E:  MOVFF  01,78
1382:  MOVFF  00,77
1386:  CLRF   x7E
1388:  CLRF   x7D
138A:  CLRF   x7C
138C:  MOVLW  81
138E:  MOVWF  x7B
1390:  CALL   07EE
1394:  MOVFF  03,56
1398:  MOVFF  02,55
139C:  MOVFF  01,54
13A0:  MOVFF  00,53
....................  
....................  //calculate True RH reading  
....................  rhtrue = ((tc - 25.0) * (0.01 + (0.00008 * rh))) + rhlin;  
13A4:  BSF    FD8.1
13A6:  MOVFF  4A,7A
13AA:  MOVFF  49,79
13AE:  MOVFF  48,78
13B2:  MOVFF  47,77
13B6:  CLRF   x7E
13B8:  CLRF   x7D
13BA:  MOVLW  48
13BC:  MOVWF  x7C
13BE:  MOVLW  83
13C0:  MOVWF  x7B
13C2:  CALL   07EE
13C6:  MOVFF  03,6A
13CA:  MOVFF  02,69
13CE:  MOVFF  01,68
13D2:  MOVFF  00,67
13D6:  MOVLW  AC
13D8:  MOVWF  x7E
13DA:  MOVLW  C5
13DC:  MOVWF  x7D
13DE:  MOVLW  27
13E0:  MOVWF  x7C
13E2:  MOVLW  71
13E4:  MOVWF  x7B
13E6:  MOVFF  66,82
13EA:  MOVFF  65,81
13EE:  MOVFF  64,80
13F2:  MOVFF  63,7F
13F6:  CALL   06FC
13FA:  BCF    FD8.1
13FC:  MOVLW  0A
13FE:  MOVWF  x7A
1400:  MOVLW  D7
1402:  MOVWF  x79
1404:  MOVLW  23
1406:  MOVWF  x78
1408:  MOVLW  78
140A:  MOVWF  x77
140C:  MOVFF  03,7E
1410:  MOVFF  02,7D
1414:  MOVFF  01,7C
1418:  MOVFF  00,7B
141C:  CALL   07EE
1420:  MOVFF  6A,7E
1424:  MOVFF  69,7D
1428:  MOVFF  68,7C
142C:  MOVFF  67,7B
1430:  MOVFF  03,82
1434:  MOVFF  02,81
1438:  MOVFF  01,80
143C:  MOVFF  00,7F
1440:  CALL   06FC
1444:  MOVFF  03,6A
1448:  MOVFF  02,69
144C:  MOVFF  01,68
1450:  MOVFF  00,67
1454:  BCF    FD8.1
1456:  MOVFF  03,7A
145A:  MOVFF  02,79
145E:  MOVFF  01,78
1462:  MOVFF  00,77
1466:  MOVFF  56,7E
146A:  MOVFF  55,7D
146E:  MOVFF  54,7C
1472:  MOVFF  53,7B
1476:  CALL   07EE
147A:  MOVFF  03,4E
147E:  MOVFF  02,4D
1482:  MOVFF  01,4C
1486:  MOVFF  00,4B
.................... }  
....................  
....................  
.................... //***** Function to measure & calculate SHT75 temp & RH *****  
....................  
.................... void sht_rd (float & temp, float & truehumid)  
.................... {  
....................  int16 restemp, reshumid;  
....................  float realhumid;  
....................  restemp = 0; truehumid = 0;  
*
11E0:  CLRF   50
11E2:  CLRF   4F
11E4:  CLRF   4E
11E6:  CLRF   4D
11E8:  CLRF   4C
11EA:  CLRF   4B
....................  
....................  restemp = measuretemp();    //measure temp  
11EC:  CALL   0676
11F0:  MOVFF  02,50
11F4:  MOVFF  01,4F
....................  reshumid = measurehumid();  //measure RH  
11F8:  CALL   06D4
11FC:  MOVFF  02,52
1200:  MOVFF  01,51
.................... calculate_data (restemp, reshumid, temp, realhumid, truehumid);  //calculate temp & RH  
1204:  MOVFF  50,60
1208:  MOVFF  4F,5F
120C:  MOVFF  52,62
1210:  MOVFF  51,61
.................... }  
....................  
....................  
.................... //***** Function to initialise SHT75 on power-up *****  
....................  
.................... void sht_init (void)  
.................... {  
....................  comreset();    //reset SHT75  
*
051C:  BRA    04D8
....................  delay_ms(20);  //delay for power-up  
051E:  MOVLW  14
0520:  MOVWF  50
0522:  RCALL  046A
0524:  GOTO   1186 (RETURN)
.................... } 
....................  
.................... //#include <MAX31855.c> 
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <LCDdriver.c> 
.................... int16 ms; 
....................  
.................... #int_timer2 
.................... void isr_timer2(void) { 
....................    ms++; //keep a running timer that increments every milli-second 
*
00AE:  INCF   1F,F
00B0:  BTFSC  FD8.2
00B2:  INCF   20,F
00B4:  BCF    F9E.1
00B6:  GOTO   0060
.................... } 
....................  
.................... void main() { 
*
10E6:  CLRF   FF8
10E8:  BCF    FD0.7
10EA:  BSF    07.7
10EC:  BSF    FB8.3
10EE:  MOVLW  81
10F0:  MOVWF  FAF
10F2:  MOVLW  00
10F4:  MOVWF  FB0
10F6:  MOVLW  A6
10F8:  MOVWF  FAC
10FA:  MOVLW  90
10FC:  MOVWF  FAB
10FE:  MOVF   FC1,W
1100:  ANDLW  C0
1102:  IORLW  0F
1104:  MOVWF  FC1
1106:  CLRF   19
1108:  CLRF   1A
110A:  CLRF   3A
110C:  CLRF   39
110E:  CLRF   38
1110:  MOVLW  1B
1112:  MOVWF  37
1114:  BCF    3B.0
1116:  BSF    3B.1
1118:  MOVLW  08
111A:  MOVWF  3C
111C:  MOVLW  03
111E:  MOVWF  3D
1120:  CLRF   3E
....................    //setup_spi(SPI_MASTER | SPI_MODE_1 | SPI_CLK_DIV_64, );  
....................    struct rx_stat rxstat; 
....................    int32 rx_id; 
....................    int in_data[8]; 
....................    int rx_len; 
....................  
.................... //send a request (tx_rtr=1) for 8 bytes of data (tx_len=8) from id 24 (tx_id=24) 
....................  
....................    int out_data_sht[8] ; // for sht 7x 
....................    int32 tx_idsht = 27; // id = 0x27 for sht7x 
....................    int1 tx_rtr=0;// CU LA 1 
....................    int1 tx_ext=1;// CU LA 0 
....................    int tx_len=8; 
....................    int tx_pri=3; 
....................  
....................  
....................    int f = 0; 
....................     
....................    for (f=0;f<8;f++) { 
1122:  CLRF   3E
1124:  MOVF   3E,W
1126:  SUBLW  07
1128:  BNC   1140
....................      
....................       out_data_sht[f]=0x22; 
112A:  CLRF   03
112C:  MOVF   3E,W
112E:  ADDLW  2F
1130:  MOVWF  FE9
1132:  MOVLW  00
1134:  ADDWFC 03,W
1136:  MOVWF  FEA
1138:  MOVLW  22
113A:  MOVWF  FEF
113C:  INCF   3E,F
113E:  BRA    1124
....................    } 
....................  
....................  //////////////////// 
.................... union conv {  
....................     float f;  
....................     int8 b[4];  
....................   }; 
....................   union conv  tempp_sht, hump_sht;  // p is alias pointer 
....................  
....................  
.................... out_data_sht[0] = tempp_sht.b[0]; 
1140:  MOVFF  3F,2F
.................... out_data_sht[1] = tempp_sht.b[1]; 
1144:  MOVFF  40,30
.................... out_data_sht[2] = tempp_sht.b[2]; 
1148:  MOVFF  41,31
.................... out_data_sht[3] = tempp_sht.b[3]; 
114C:  MOVFF  42,32
....................  
.................... out_data_sht[4] = hump_sht.b[0]; 
1150:  MOVFF  43,33
.................... out_data_sht[5] = hump_sht.b[1]; 
1154:  MOVFF  44,34
.................... out_data_sht[6] = hump_sht.b[2]; 
1158:  MOVFF  45,35
.................... out_data_sht[7] = hump_sht.b[3]; 
115C:  MOVFF  46,36
....................  
.................... //printf(" %4.4f : %x : %x : %x : %x \r\n",val2.f,\  
.................... //    val2.b[0],val2.b[1],val2.b[2],val2.b[3]);  
.................... //    //The new float value, and the bytes that make it.  
....................  
....................  ////////////////////  
.................... // float temp,press,hu; 
....................  float truetempsht, truehumidsht; 
....................    printf("\r\n\r\nCCS CAN TRANSFER BME280 DATA\r\n"); 
1160:  MOVLW  BA
1162:  MOVWF  FF6
1164:  MOVLW  00
1166:  MOVWF  FF7
1168:  CALL   01EA
....................  
....................    setup_timer_2(T2_DIV_BY_4,79,16);   //setup up timer2 to interrupt every 1ms if using 20Mhz clock 
116C:  MOVLW  78
116E:  IORLW  05
1170:  MOVWF  FCA
1172:  MOVLW  4F
1174:  MOVWF  FCB
....................  
....................    can_init(); 
1176:  GOTO   038E
....................    //init_BME280(); 
....................    //BME280Begin(); 
....................    delay_ms(200); 
117A:  MOVLW  C8
117C:  MOVWF  50
117E:  CALL   046A
....................    sht_init() ;// init sht75 
1182:  GOTO   051C
....................    delay_ms(10); 
1186:  MOVLW  0A
1188:  MOVWF  50
118A:  CALL   046A
....................     
....................   // can_set_mode(CAN_OP_LOOPBACK); 
....................    
....................    enable_interrupts(INT_TIMER2);   //enable timer2 interrupt 
118E:  BSF    F9D.1
....................    enable_interrupts(GLOBAL);       //enable all interrupts (else timer2 wont happen) 
1190:  MOVLW  C0
1192:  IORWF  FF2,F
....................  
....................    printf("\r\nRunning..."); 
1194:  MOVLW  DE
1196:  MOVWF  FF6
1198:  MOVLW  00
119A:  MOVWF  FF7
119C:  CALL   01EA
....................     
....................     
....................    while(TRUE) 
....................    {    
....................          
....................         truetempsht = measuretemp(); 
11A0:  CALL   0676
11A4:  MOVFF  02,74
11A8:  MOVFF  01,73
11AC:  CALL   069E
11B0:  MOVFF  03,4A
11B4:  MOVFF  02,49
11B8:  MOVFF  01,48
11BC:  MOVFF  00,47
....................         truehumidsht = measurehumid(); 
11C0:  CALL   06D4
11C4:  MOVFF  02,74
11C8:  MOVFF  01,73
11CC:  CALL   069E
11D0:  MOVFF  03,4E
11D4:  MOVFF  02,4D
11D8:  MOVFF  01,4C
11DC:  MOVFF  00,4B
....................         sht_rd(truetempsht,truehumidsht); 
....................         delay_ms(10); 
*
148A:  MOVLW  0A
148C:  MOVWF  50
148E:  CALL   046A
....................         printf("\r\nTemperature SHT71 = %f3",truetempsht); 
1492:  MOVLW  EC
1494:  MOVWF  FF6
1496:  MOVLW  00
1498:  MOVWF  FF7
149A:  MOVLW  16
149C:  MOVWF  53
149E:  CALL   0A58
14A2:  MOVLW  89
14A4:  MOVWF  FE9
14A6:  MOVFF  4A,52
14AA:  MOVFF  49,51
14AE:  MOVFF  48,50
14B2:  MOVFF  47,4F
14B6:  MOVLW  02
14B8:  MOVWF  53
14BA:  CALL   0B46
14BE:  MOVLW  33
14C0:  BTFSS  F9E.4
14C2:  BRA    14C0
14C4:  MOVWF  FAD
....................         printf("\r\nHumidity SHT71 = %f3",truehumidsht); 
14C6:  MOVLW  06
14C8:  MOVWF  FF6
14CA:  MOVLW  01
14CC:  MOVWF  FF7
14CE:  MOVLW  13
14D0:  MOVWF  53
14D2:  CALL   0A58
14D6:  MOVLW  89
14D8:  MOVWF  FE9
14DA:  MOVFF  4E,52
14DE:  MOVFF  4D,51
14E2:  MOVFF  4C,50
14E6:  MOVFF  4B,4F
14EA:  MOVLW  02
14EC:  MOVWF  53
14EE:  CALL   0B46
14F2:  MOVLW  33
14F4:  BTFSS  F9E.4
14F6:  BRA    14F4
14F8:  MOVWF  FAD
....................          
....................          tempp_sht.f = truetempsht;         
14FA:  MOVFF  4A,42
14FE:  MOVFF  49,41
1502:  MOVFF  48,40
1506:  MOVFF  47,3F
....................          out_data_sht[0] = tempp_sht.b[0]; 
150A:  MOVFF  3F,2F
....................          out_data_sht[1] = tempp_sht.b[1]; 
150E:  MOVFF  40,30
....................          out_data_sht[2] = tempp_sht.b[2]; 
1512:  MOVFF  41,31
....................          out_data_sht[3] = tempp_sht.b[3]; 
1516:  MOVFF  42,32
....................           
....................          hump_sht.f =truehumidsht; 
151A:  MOVFF  4E,46
151E:  MOVFF  4D,45
1522:  MOVFF  4C,44
1526:  MOVFF  4B,43
....................          out_data_sht[4] = hump_sht.b[0]; 
152A:  MOVFF  43,33
....................          out_data_sht[5] = hump_sht.b[1]; 
152E:  MOVFF  44,34
....................          out_data_sht[6] = hump_sht.b[2]; 
1532:  MOVFF  45,35
....................          out_data_sht[7] = hump_sht.b[3]; 
1536:  MOVFF  46,36
....................           delay_ms(10); 
153A:  MOVLW  0A
153C:  MOVWF  50
153E:  CALL   046A
....................    
....................       if ( can_kbhit() )   //if data is waiting in buffer... 
1542:  BTFSC  F60.7
1544:  BRA    154E
1546:  MOVLB  F
1548:  BTFSS  x50.7
154A:  BRA    17DA
154C:  MOVLB  0
....................       { 
....................          if(can_getd(rx_id, &in_data[0], rx_len, rxstat)) { //...then get data from buffer 
154E:  CLRF   50
1550:  MOVLW  26
1552:  MOVWF  4F
*
1652:  MOVF   01,F
1654:  BTFSC  FD8.2
1656:  BRA    17CA
....................             printf("\r\nGOT: BUFF=%U ID=%LU LEN=%U OVF=%U ", rxstat.buffer, rx_id, rx_len, rxstat.err_ovfl); 
1658:  MOVLW  00
165A:  BTFSC  21.4
165C:  MOVLW  01
165E:  MOVWF  4F
1660:  MOVLW  00
1662:  BTFSC  21.0
1664:  MOVLW  01
1666:  MOVWF  50
1668:  MOVLW  1E
166A:  MOVWF  FF6
166C:  MOVLW  01
166E:  MOVWF  FF7
1670:  MOVLW  0C
1672:  MOVWF  53
1674:  MOVLB  0
1676:  CALL   0A58
167A:  MOVFF  4F,53
167E:  MOVLW  1B
1680:  MOVWF  54
1682:  RCALL  0ED0
1684:  MOVLW  2C
1686:  MOVWF  FF6
1688:  MOVLW  01
168A:  MOVWF  FF7
168C:  MOVLW  04
168E:  MOVWF  53
1690:  CALL   0A58
1694:  MOVLW  41
1696:  MOVWF  FE9
1698:  MOVFF  25,54
169C:  MOVFF  24,53
16A0:  MOVFF  23,52
16A4:  MOVFF  22,51
16A8:  RCALL  0F3C
16AA:  MOVLW  33
16AC:  MOVWF  FF6
16AE:  MOVLW  01
16B0:  MOVWF  FF7
16B2:  MOVLW  05
16B4:  MOVWF  53
16B6:  CALL   0A58
16BA:  MOVFF  2E,53
16BE:  MOVLW  1B
16C0:  MOVWF  54
16C2:  RCALL  0ED0
16C4:  MOVLW  3A
16C6:  MOVWF  FF6
16C8:  MOVLW  01
16CA:  MOVWF  FF7
16CC:  MOVLW  05
16CE:  MOVWF  53
16D0:  CALL   0A58
16D4:  MOVFF  50,53
16D8:  MOVLW  1B
16DA:  MOVWF  54
16DC:  CALL   0ED0
16E0:  MOVLW  20
16E2:  BTFSS  F9E.4
16E4:  BRA    16E2
16E6:  MOVWF  FAD
....................             printf("FILT=%U RTR=%U EXT=%U INV=%U", rxstat.filthit, rxstat.rtr, rxstat.ext, rxstat.inv); 
16E8:  MOVFF  21,00
16EC:  RRCF   21,W
16EE:  ANDLW  07
16F0:  MOVWF  4F
16F2:  MOVLW  00
16F4:  BTFSC  21.5
16F6:  MOVLW  01
16F8:  MOVWF  50
16FA:  MOVLW  00
16FC:  BTFSC  21.6
16FE:  MOVLW  01
1700:  MOVWF  51
1702:  MOVLW  00
1704:  BTFSC  21.7
1706:  MOVLW  01
1708:  MOVWF  52
170A:  MOVLW  44
170C:  MOVWF  FF6
170E:  MOVLW  01
1710:  MOVWF  FF7
1712:  MOVLW  05
1714:  MOVWF  53
1716:  CALL   0A58
171A:  MOVFF  4F,53
171E:  MOVLW  1B
1720:  MOVWF  54
1722:  CALL   0ED0
1726:  MOVLW  4B
1728:  MOVWF  FF6
172A:  MOVLW  01
172C:  MOVWF  FF7
172E:  MOVLW  05
1730:  MOVWF  53
1732:  CALL   0A58
1736:  MOVFF  50,53
173A:  MOVLW  1B
173C:  MOVWF  54
173E:  CALL   0ED0
1742:  MOVLW  52
1744:  MOVWF  FF6
1746:  MOVLW  01
1748:  MOVWF  FF7
174A:  MOVLW  05
174C:  MOVWF  53
174E:  CALL   0A58
1752:  MOVFF  51,53
1756:  MOVLW  1B
1758:  MOVWF  54
175A:  CALL   0ED0
175E:  MOVLW  59
1760:  MOVWF  FF6
1762:  MOVLW  01
1764:  MOVWF  FF7
1766:  MOVLW  05
1768:  MOVWF  53
176A:  CALL   0A58
176E:  MOVFF  52,53
1772:  MOVLW  1B
1774:  MOVWF  54
1776:  CALL   0ED0
....................             printf("\r\n    DATA = "); 
177A:  MOVLW  62
177C:  MOVWF  FF6
177E:  MOVLW  01
1780:  MOVWF  FF7
1782:  CALL   01EA
....................             for (f=0;f<rx_len;f++) { 
1786:  CLRF   3E
1788:  MOVF   2E,W
178A:  SUBWF  3E,W
178C:  BC    17B6
....................                printf("%X ",in_data[f]); 
178E:  CLRF   03
1790:  MOVF   3E,W
1792:  ADDLW  26
1794:  MOVWF  FE9
1796:  MOVLW  00
1798:  ADDWFC 03,W
179A:  MOVWF  FEA
179C:  MOVFF  FEF,4F
17A0:  MOVFF  4F,50
17A4:  MOVLW  37
17A6:  MOVWF  51
17A8:  RCALL  0FE2
17AA:  MOVLW  20
17AC:  BTFSS  F9E.4
17AE:  BRA    17AC
17B0:  MOVWF  FAD
17B2:  INCF   3E,F
17B4:  BRA    1788
....................             } 
....................             printf("\r\n"); 
17B6:  MOVLW  0D
17B8:  BTFSS  F9E.4
17BA:  BRA    17B8
17BC:  MOVWF  FAD
17BE:  MOVLW  0A
17C0:  BTFSS  F9E.4
17C2:  BRA    17C0
17C4:  MOVWF  FAD
....................          } 
17C6:  BRA    17D8
17C8:  MOVLB  F
....................          else { 
....................             printf("\r\nFAIL on GETD\r\n"); 
17CA:  MOVLW  70
17CC:  MOVWF  FF6
17CE:  MOVLW  01
17D0:  MOVWF  FF7
17D2:  MOVLB  0
17D4:  CALL   01EA
17D8:  MOVLB  F
....................          } 
....................  
....................       } 
....................       //every two seconds, send new data if transmit buffer is empty 
....................       if ( can_tbe() && (ms > 2000)) 
17DA:  BTFSS  x40.3
17DC:  BRA    17E6
17DE:  BTFSS  x30.3
17E0:  BRA    17E6
17E2:  BTFSC  x20.3
17E4:  BRA    19EA
17E6:  MOVF   20,W
17E8:  SUBLW  06
17EA:  BTFSC  FD8.0
17EC:  BRA    19EA
17EE:  XORLW  FF
17F0:  BNZ   17FA
17F2:  MOVF   1F,W
17F4:  SUBLW  D0
17F6:  BTFSC  FD8.0
17F8:  BRA    19EA
....................       { 
....................          ms=0;     
17FA:  CLRF   20
17FC:  CLRF   1F
....................          f=can_putd(tx_idsht, out_data_sht, tx_len,tx_pri,tx_ext,tx_rtr); //put data on transmit buffer 
17FE:  MOVLW  00
1800:  BTFSC  3B.1
1802:  MOVLW  01
1804:  MOVWF  4F
1806:  MOVLW  00
1808:  BTFSC  3B.0
180A:  MOVLW  01
180C:  MOVWF  50
180E:  MOVFF  3A,54
1812:  MOVFF  39,53
1816:  MOVFF  38,52
181A:  MOVFF  37,51
181E:  CLRF   56
1820:  MOVLW  2F
1822:  MOVWF  55
1824:  MOVFF  3C,57
1828:  MOVFF  3D,58
182C:  MOVFF  4F,59
1830:  MOVFF  50,5A
1834:  MOVLB  0
1836:  GOTO   1024
183A:  MOVFF  01,3E
....................          if(f != 0xFF) 
183E:  INCFSZ 3E,W
1840:  BRA    1844
1842:  BRA    19DC
....................          {     
....................                printf("\r\nPUT %U: ID=%LU LEN=%U ", f, tx_idsht, tx_len);  //i return 1 if transmit success 
1844:  MOVLW  82
1846:  MOVWF  FF6
1848:  MOVLW  01
184A:  MOVWF  FF7
184C:  MOVLW  06
184E:  MOVWF  53
1850:  CALL   0A58
1854:  MOVFF  3E,53
1858:  MOVLW  1B
185A:  MOVWF  54
185C:  CALL   0ED0
1860:  MOVLW  8A
1862:  MOVWF  FF6
1864:  MOVLW  01
1866:  MOVWF  FF7
1868:  MOVLW  05
186A:  MOVWF  53
186C:  CALL   0A58
1870:  MOVLW  41
1872:  MOVWF  FE9
1874:  MOVFF  3A,54
1878:  MOVFF  39,53
187C:  MOVFF  38,52
1880:  MOVFF  37,51
1884:  CALL   0F3C
1888:  MOVLW  92
188A:  MOVWF  FF6
188C:  MOVLW  01
188E:  MOVWF  FF7
1890:  MOVLW  05
1892:  MOVWF  53
1894:  CALL   0A58
1898:  MOVFF  3C,53
189C:  MOVLW  1B
189E:  MOVWF  54
18A0:  CALL   0ED0
18A4:  MOVLW  20
18A6:  BTFSS  F9E.4
18A8:  BRA    18A6
18AA:  MOVWF  FAD
....................                printf("PRI=%U EXT=%U RTR=%U\r\n   DATA = ", tx_pri, tx_ext, tx_rtr); 
18AC:  MOVLW  00
18AE:  BTFSC  3B.1
18B0:  MOVLW  01
18B2:  MOVWF  4F
18B4:  MOVLW  00
18B6:  BTFSC  3B.0
18B8:  MOVLW  01
18BA:  MOVWF  50
18BC:  MOVLW  9C
18BE:  MOVWF  FF6
18C0:  MOVLW  01
18C2:  MOVWF  FF7
18C4:  MOVLW  04
18C6:  MOVWF  53
18C8:  CALL   0A58
18CC:  MOVFF  3D,53
18D0:  MOVLW  1B
18D2:  MOVWF  54
18D4:  CALL   0ED0
18D8:  MOVLW  A2
18DA:  MOVWF  FF6
18DC:  MOVLW  01
18DE:  MOVWF  FF7
18E0:  MOVLW  05
18E2:  MOVWF  53
18E4:  CALL   0A58
18E8:  MOVFF  4F,53
18EC:  MOVLW  1B
18EE:  MOVWF  54
18F0:  CALL   0ED0
18F4:  MOVLW  A9
18F6:  MOVWF  FF6
18F8:  MOVLW  01
18FA:  MOVWF  FF7
18FC:  MOVLW  05
18FE:  MOVWF  53
1900:  CALL   0A58
1904:  MOVFF  50,53
1908:  MOVLW  1B
190A:  MOVWF  54
190C:  CALL   0ED0
1910:  MOVLW  B0
1912:  MOVWF  FF6
1914:  MOVLW  01
1916:  MOVWF  FF7
1918:  MOVLW  0C
191A:  MOVWF  53
191C:  CALL   0A58
....................                for (f=0;f<tx_len;f++) { 
1920:  CLRF   3E
1922:  MOVF   3C,W
1924:  SUBWF  3E,W
1926:  BC    1962
....................                printf("\r\n%X ",out_data_sht[f]); 
1928:  CLRF   03
192A:  MOVF   3E,W
192C:  ADDLW  2F
192E:  MOVWF  FE9
1930:  MOVLW  00
1932:  ADDWFC 03,W
1934:  MOVWF  FEA
1936:  MOVFF  FEF,4F
193A:  MOVLW  0D
193C:  BTFSS  F9E.4
193E:  BRA    193C
1940:  MOVWF  FAD
1942:  MOVLW  0A
1944:  BTFSS  F9E.4
1946:  BRA    1944
1948:  MOVWF  FAD
194A:  MOVFF  4F,50
194E:  MOVLW  37
1950:  MOVWF  51
1952:  CALL   0FE2
1956:  MOVLW  20
1958:  BTFSS  F9E.4
195A:  BRA    1958
195C:  MOVWF  FAD
195E:  INCF   3E,F
1960:  BRA    1922
....................             } 
....................              printf("\r\n"); 
1962:  MOVLW  0D
1964:  BTFSS  F9E.4
1966:  BRA    1964
1968:  MOVWF  FAD
196A:  MOVLW  0A
196C:  BTFSS  F9E.4
196E:  BRA    196C
1970:  MOVWF  FAD
....................              printf("\r\nPUT %U: ID=%LU LEN=%U ", f, tx_idsht, tx_len); 
1972:  MOVLW  BE
1974:  MOVWF  FF6
1976:  MOVLW  01
1978:  MOVWF  FF7
197A:  MOVLW  06
197C:  MOVWF  53
197E:  CALL   0A58
1982:  MOVFF  3E,53
1986:  MOVLW  1B
1988:  MOVWF  54
198A:  CALL   0ED0
198E:  MOVLW  C6
1990:  MOVWF  FF6
1992:  MOVLW  01
1994:  MOVWF  FF7
1996:  MOVLW  05
1998:  MOVWF  53
199A:  CALL   0A58
199E:  MOVLW  41
19A0:  MOVWF  FE9
19A2:  MOVFF  3A,54
19A6:  MOVFF  39,53
19AA:  MOVFF  38,52
19AE:  MOVFF  37,51
19B2:  CALL   0F3C
19B6:  MOVLW  CE
19B8:  MOVWF  FF6
19BA:  MOVLW  01
19BC:  MOVWF  FF7
19BE:  MOVLW  05
19C0:  MOVWF  53
19C2:  CALL   0A58
19C6:  MOVFF  3C,53
19CA:  MOVLW  1B
19CC:  MOVWF  54
19CE:  CALL   0ED0
19D2:  MOVLW  20
19D4:  BTFSS  F9E.4
19D6:  BRA    19D4
19D8:  MOVWF  FAD
....................          } 
19DA:  BRA    19E8
....................           else { //fail, no transmit buffer was open 
....................             printf("\r\nFAIL on PUTD\r\n"); 
19DC:  MOVLW  D8
19DE:  MOVWF  FF6
19E0:  MOVLW  01
19E2:  MOVWF  FF7
19E4:  CALL   01EA
19E8:  MOVLB  F
....................          
....................          } 
....................       } 
....................     
....................        
....................      delay_ms(500);  
19EA:  MOVLW  02
19EC:  MOVWF  4F
19EE:  MOVLW  FA
19F0:  MOVWF  50
19F2:  MOVLB  0
19F4:  CALL   046A
19F8:  DECFSZ 4F,F
19FA:  BRA    19FE
19FC:  BRA    1A02
19FE:  MOVLB  F
1A00:  BRA    19EE
1A02:  GOTO   11A0
....................    } 
.................... } 
1A06:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
